📚 블로그 읽고 세션과 토큰 정리해보기

- 세션 방식과 토큰 방식의 가장 큰 차이는 무엇인가요? 🍠
  **“사용자의 상태 정보를 어디에 저장하는지”**
  **세션 방식**:
  사용자 정보를 **서버에 저장**
  클라이언트는 그 정보를 찾을 수 있는 키(세션ID)만 전달
  **토큰 방식**:
  사용자 정보를 **토큰 자체에 포함**시켜
  클라이언트가 직접 보관하고 전송
  세션기반이든, 토큰 기반이든, 결국 인증정보를 클라이언트와 서버 사이에 주고 받아야함.
  ⇒ 세션 ID든 JWT 토큰이든 결국은 HTTP 요청에 포함시켜 전송해야한다
- 세션을 분산 환경에서 관리할 때 사용할 수 있는 세 가지 전략(Sticky Session, Session Replication, Centralized Session Store)의 특징을 정리해주세요. 🍠
  세션 저장소를 어디에 두는지

  1. 메모리 저장(단일 서버)

     : 가장 빠르지만 서버 재시작 시 모든 세션이 사라짐

  2. Redis 같은 인메모리 데이터베이스 사용(분산 환경)

     : 속도와 영속성 모두 얻을 수 있음. 분산환경에서 여러 서버가 세션 공유할 수 있고, 서버 재시작에도 세션 유지

  3. 관계형 데이터베이스 저장

     : 가장 안정적이지만 다른 방식에 비해 성능 떨어짐

  ***

  서버가 여러 대인 분산환경에서는 어떻게 세션 공유? -사용자가 서버A에서 로그인했는데, 다음 요청이 서버B로 간다면..? → 세션 찾을 수 없을 것.
  ⇒해결방법 3가지

  - Sticky Session(세션 고정): 로드밸런서가 같은 사용자의 요청을 **항상 같은 서버로 보내는** 방식
    - 장점: 구현이 간단
    - 단점: 서버 장애시 해당 서버의 모든 세션이 사라짐
  - Session Replication(세션 복제): 모든 서버가 세션 정보를 공유하는 방식
    - 서버간 네트워크 통신 많아져→성능 떨어질 수 있음
  - Centralized Session Store(중앙 세션 저장소): Redis같은 **별도 저장소에 모든 세션 보관**하는 방식
    - 현재 가장 널리 사용됨

- JWT(Json Web Token)의 장점과 단점을 각각 설명해주세요. 🍠
  토큰→ 사용자 정보(사용자 ID, 권한, 만료시간 등)를 **토큰 자체에 포함**
  서버의 비밀 키로 서명
  서버는 서명 검증→토큰의 유효성 확인 가능
  ***
  -장점: 확장성
  서버가 100대든 1000대든, 각 서버는 독립적으로 토큰 검증 가능
  →MSA에서 각 서비스가 독립적으로 인증 처리 가능 -단점: 한번 발급한 토큰은 만료될때까지 유효
  → 보안이슈(사용자 강제 로그아웃)가 있을 때 즉시 처리하기 어려움
  이 문제를 해결하기 위해 블랙리스트를 두고 만료 시간을 짧게 설정하는 등의 추가적인 처리 필요
- JWT의 즉시 무효화 문제가 생기는 이유와 이를 해결하기 위한 방법은 무엇인가요? 🍠
  한번 발급한 토큰은 만료될 때까지 유효하므로
  사용자 강제 로그아웃같은 보안이슈가 있을 때 즉시 처리(무효화)하기 어려움
  ⇒블랙리스트를 두고 만료 시간을 짧게 설정하는 등의 추가적인 처리 필요
- 세션과 토큰을 결합한 하이브리드 방식(JWT + 저장소 메타데이터)의 동작 원리를 간단히 설명해주세요. 🍠
  **세션과 토큰의 장점을 결합한 방식**:
  1. JWT의 JTI(JWT ID) 클레임을 활용해 각 토큰에 고유 ID 부여
  2. 로그아웃 시 이 ID를 블랙리스트에 등록
  3. 각 요청이 들어와서 토큰을 검증할 때, 블랙리스트에 들어있는지 확인하고, 업는 경우 서명 검증
     ⇒JWT의 확장성과 세션의 제어권 모두 가질 수 있음

📚 블로그 읽고 쿠키 정리해보기! 🍠

- HTTP는 왜 무상태(Stateless)로 설계되었나요? 🍠
  HTTP: 클라이언트와 서버 간의 통신 프로토콜
  무상태(Stateless) 특성 가짐
  : 서버가 각 요청을 완전히 독립적으로 처리하며, 이전 요청의 정보를 메모리에 유지하지 않음
  ⇒ 로그인의 요청을 보내서 로그인에 성공했어도, 이후 요청에서는 서버는 이전 로그인 컨텍스트를 알 수 없음
  ***
  ### 왜 무상태로 설계되었을까?
  **#무상태성의 아키텍처적 이점**
  1990년대 초 웹이 처음 만들어질 때, 단순한 문서 전송이 주 목적이었음. → 수백만명의 사용자가 동시에 접속하는 대규모 서비스는 상상하기 어려웠음
  ⇒**확장성, 단순성을 확보**하기 위해 무상태성으로 설계함
- HTTP의 무상태성이 주는 장점과 단점을 각각 정리해주세요. 🍠
  **장점**
  - 확장성: 서버를 수평적으로 확장하기 쉬움
    - 어떤 서버든 요청을 처리할 수 있으니 로드밸런서가 단순히 트래픽만 분산하면 됨
  - 신뢰성: 서버 하나가 죽어도 다른 서버가 즉시 대체 가능
    - 유지할 상태가 없어서 복구 간단
  - 단순성: 서버가 클라이언트별 상태를 관리하지 않아도 됨
    - 구현 단순
  ***
  **단점**
  - 현대의 웹 애플리케이션은 단순한 문서조회를 넘어 복잡한 상호작용을 요구하고 연속성 있는 작업이 필요함
  - 로그인하면 여러 페이지를 이동해도 계속 로그인 상태가 유지되어야 함
  - 쇼핑몰에서 상품을 장바구니에 담으면 다른 상품을 둘러봐도 장바구니가 유지되어야 함
  - 회원가입 시 여러 단계를 거치면서도 이전 단계의 입력 정보가 보존되어야 함
- 쿠키의 Domain 디렉티브에 대해 정리해주세요. 🍠
  : 어떤 웹사이트(도메인)에서 이 쿠키를 사용할 수 있는지 범위를 지정해주는 설정
  즉, 쿠키의 **‘사용 가능 지역’** 정해주는 주소표
  ***
  ### Domain 디렉티브의 기본적인 개념
  도메인 디렉티브는 서버가 클라이언트(브라우저)에게 쿠키를 보낼 때, 쿠키 헤더(Header)에 함께 포함하여 전달하는 속성 중 하나
  1. 역할
     1. **쿠키가 유효한 도메인 정의**
     2. 브라우저는 이 쿠키를 오직 이 속성에 지정된 도메인 또는 그 하위 도메인으로 요청을 보낼 때만 첨부해서 서버에 전송
  2. 설정 방식
     1. Set-Cookie: name=value; Domain=example.com
     2. 이 경우 브라우저는 `example.com`과 이의 하위 도메인들(`www.example.com`, [blog.example.com](http://blog.example.com) 등)로 요청을 보낼 때만 해당 쿠키를 함께 전송
  3. 기본값(Domain 속성이 없는 경우)
     1. 만약 Domain 속성을 명시하지 않으면, 쿠키는 기본적으로 **쿠키를 설정한 서버의 정확한 호스트 이름으로만** 유효
     2. ex: `www.example.com`에서 쿠키를 설정했는데 Domain 속성이 없다면, 오직 www.example.com으로의 요청에만 이 쿠키가 전송되고, `blog.example.com`이나 example.com으로의 요청에는 전송되지 않음
  ***
  ### Domain 디렉티브의 작동원리 및 예시
  도메인 디렉티브의 핵심: **서브 도베인간의 쿠키 공유**를 가능하게 하는 것
  ![스크린샷 2025-10-06 오후 5.15.04.png](attachment:9fe089a7-56db-4770-bf68-9d2c80bf11ce:스크린샷_2025-10-06_오후_5.15.04.png)
  **중요한 보안 규칙 (점(.)규칙)**
  1. **쿠키는 상위 도메인을 명시해야 한다**
     1. 쿠키를 설정할 때 Domain 값은 반드시 현재 쿠키를 설정하는 서버의 **상위 도메인**이거나 동일한 도메인이어야 한다.
  2. **다른 웹사이트의 도메인은 설정할 수 없다**
     1. `example.com`에서 쿠키를 설정하면서 `Domain=naver.com`이라고 설정할 수는 없음
     2. 만약 이것이 허용된다면, 악의적인 웹사이트가 다른 웹사이트의 사용자 정보를 빼낼 수 있는 심각한 보안 문제가 발생할 수 있음
- 쿠키의 Path 디렉티브에 대해 정리해주세요. 🍠
  : 웹사이트의 **특정 경로(디렉토리)에서만 쿠키를 사용할 수 있도록 접근 범위를 설정**하는 속성
  쉽게 말해, 쿠키의 ‘사용 가능 구역’을 특정 폴더로 지정해주는 역할

  ***

  ### Path 디렉티브의 기본 개념

  : 서버가 클라이언트(브라우저)에게 쿠키를 보낼 때, Set-Cookie 헤더에 포함하여 전달하는 속성 중 하나

  1. 역할
     1. **쿠키가 유효한 경로(URL의 경로 부분)** 정의
     2. 브라우저는 이 속성에 지정된 경로나 그 하위 경로로 요청을 보낼 때만 해당 쿠키를 서버에 첨부하여 전송한다
  2. 설정 방식
     1. Set-Cookie: name=value; Path=/경로
     2. Set-Cookie: token=abcd123; Path=/admin

  ***

  ### Path 디렉티브의 작동 원리 및 예시

  Path 디렉티브는 웹사이트 내의 서로 다른 영역에 따라 쿠키 사용을 분리할 때 유용함

  1. 기본 동작 (디렉티브가 없는 경우)
     1. Path 디렉티브를 명시하지 않으면, 쿠키는 기본적으로 쿠키를 설정한 페이지의 경로로 자동 설정됨
     2. ex) [www.example.com/user/profile](http://www.example.com/user/profile) 페이지에서 쿠키를 설정하면, Path는 /user/ 로 설정됨
  2. 설정에 따른 유효 범위
     | 설정 값 | 쿠키를 설정한 URL | 유효한 요청 경로(쿠키가 전송되는 경로) |
     | ---------------- | ----------------------------- | ----------------------------------------------------------------------------------------- |
     | Path=/ | www.site.com/ | [www.site.com](http://www.site.com) 도메인의 모든 경로 |
     | Path=/admin | www.site.com/admin/login | /admin, /admin/users, /admin/settings 등 /admin으로 시작하는 모든 하위 경로 |
     | Path=/board/free | www.site.com/board/free/write | /board/free, /board/free/123, /board/free/search 등 /board/free로 시작하는 모든 하위 경로 |

  ***

  ### Path 디렉티브의 활용 및 주의 사항

  1. 쿠키 분리

     특정 기능(예: 장바구니)에만 필요한 쿠키를 /shop/ 경로로 제한하면, 다른 경로(/blog/)로 요청을 보낼 때 불필요한 쿠키가 전송되는 것을 막아 네트워크 효율성을 높일 수 있다

  2. 보안 및 오버라이딩
     1. Path 디렉티브는 보안 기능으로 활용됨
     2. 쿠키의 유효 범위를 좁힘으로써, 특정 영역에서만 민감한 정보를 담은 쿠키가 전송되도록 제한할 수 있다.
     3. 만약 경로가 다른 두 개의 쿠키가 같은 이름을 가지고 있다면, 더 구체적인 경로(긴 경로)를 가진 쿠키가 먼저 서버로 전송된다(오버라이딩)
        주의: 브라우저는 지정된 경로가 요청 URL의 시작 부분과 일치하는지만 확인하며, 지정된 경로 내부에 해당 파일이 실제로 존재하는지 여부는 확인하지 않음

- 세션 쿠키와, 영속 쿠키의 차이점을 정리해주세요. 🍠
  가장 큰 차이점: 정보가 저장되는 위치, 유효기간
  ***
  ### 세션 쿠키(Session Cookie)
  “일시적인 메모” 역할
  - 저장 위치
    - 웹 브라우저의 메모리(RAM)
  - 유효 기간
    - 브라우저 창이 닫힐 때까지만 유효
  - 만료설정
    - 쿠키 생성 시 Expires나 Max-Age 속성을 따로 설정하지 않음
  - 주요 용도
    - 로그인 상태 유지(로그인 후 탐색)
    - 일회성 장바구니 정보
  - 작동 원리
    - 사용자가 웹 브라우저를 닫는 순간 메모리에서 자동 삭제
  - 비유
    - 놀이공원 당일 티켓(오늘 하루만 유효)
      예시
      은행 웹사이트에 로그인 한 후 여러 페이지를 이동
      →이 상태를 유지하는 것이 세션 쿠키의 역할
      작업을 마치고 브라우저 창을 닫으면 자동으로 로그아웃
      다음에 브라우저를 다시 열고 은행 사이트에 접속하면 다시 로그인해야함
  ***
  ### 영속적 쿠키
  “장기간 보존되는 기록”
  - 저장 위치
    - 사용자의 컴퓨터 하드 드라이브(파일 형태)
  - 유효 기간
    - 쿠키 생성 시 설정한 만료 일자까지 유효
  - 만료 설정
    - Expires(만료날짜)나 Max-Age(만료까지 남은 시간:초) 속성을 반드시 명시해야함
  - 주요 용도
    - 아이디 저장
    - 로그인 상태 유지(며칠/ 몇 주 동안)
    - 웹사이트 환경 설정(테마, 언어 설정)
    - 사용자 추적
  - 작동 원리
    - 브라우저를 닫아도 삭제되지 않고, 만료일이 지나야 삭제되거나 수동으로 삭제해야함
  - 비유
    - 유효기간이 정해진 멤버십 카드 (기간 만료 전까지 계속 사용 가능)
      예시
      쇼핑몰 웹사이트에서 ‘아이디 저장’ 옵션을 선택
      →이 아이디 정보는 영속적 쿠키로 저장됨
      브라우저를 닫았다가 며칠 뒤 다시 쇼핑몰에 접속해도 해당 쿠키가 살아있어 아이디 입력창에 ID가 남아있거나 자동 로그인 상태가 유지됨
  ***
  ### 핵심 차이점 요약
  | 구분      | 세션 쿠키                               | 영속적 쿠키                                 |
  | --------- | --------------------------------------- | ------------------------------------------- |
  | 저장 장소 | 메모리(RAM)                             | 하드 디스크(파일)                           |
  | 유효 기간 | 브라우저 종료 시점까지                  | 설정된 만료 시점까지                        |
  | 만료 설정 | 설정하지 않음                           | Expires 또는 Max-Age 설정 필수              |
  | 보안      | 비교적 안전(브라우저 종료 시 바로 삭제) | 상대적으로 취약 (오랜 기간 파일로 남아있음) |
- 쿠키의 보안 속성(HttpOnly, Secure, SameSite)은 각각 어떤 공격을 방어하나요? 🍠
  각각이 **특정 공격을 방어**하는 역할
  - HttpOnly: JavaScript에서 쿠키에 접근하는 것 막아줌
    - XSS(Cross-Site Scripting) 공격으로 쿠키를 탈취하는 것 방지 가능
    - EX) 해커가 게시판에 악성 스크립트를 삽입하더라도 document.cookie로 세션 쿠키를 읽을 수 없게됨
  - Secure: HTTPS 연결에서만 쿠키를 전송하도록 제한
    - 중간자 공격(Man-in-the-Middle)방지
    - 공공 Wifi같은 안전하지 않은 네트워크에서도 쿠키가 평문으로 전송되지 않도록 보호
  - Samsite: CSRF(Cross-Site Request Forgery) 공격을 방어
    - Strict: 같은 사이트에서만 쿠키 전송
    - Lax: 안전한 HTTP 메소드(GET)로 최상위 네비게이션 시에만 쿠키 전송
    - None: 모든 크로스 사이트 요청 허용(Secure 필수)
- 쿠키의 한계점(용량, 보안, 네트워크, 도메인 제약)을 정리해주세요. 🍠
  1. 용량 제한
     1. 각 쿠키는 4KB까지만 저장 가능
     2. 브라우저마다 도메인당 쿠키 개수 제한됨
  2. 보안 취약성
     1. 쿠키는 클라이언트 측에 저장되므로 사용자가 조작할 수 있음
     2. EX) 쿠키에 role-user 값을 저장했다면, 개발자 도구를 통해 role=admin으로 변경 가능
  3. 네트워크 오버헤드
     1. 쿠키는 해당 도메인의 모든 요청에 자동으로 포함됨
     2. 이미지나 CSS 파일 요청에도 불필요하게 전송될 수 있음
  4. 도메인 제약
     1. 보안상의 이유로 쿠키는 설정된 도메인에서만 접근 가능
     2. ex) `api.example.com`에서 설정한 쿠키를 `another-site.com`에서는 읽을 수 없음
     3. 이는 보안을 위한 필수적인 제약이지만, 마이크로서비스 아키텍처처럼 여러 도메인에 걸쳐 서비스가 분산되어 있거나, 파트너 사이트와 인증을 공유해야하는 SSO(Single Sign-On) 구현 시 제약됨
- 쿠키만으로 상태 관리를 해결할 수 없는 이유는 무엇인가요? 🍠
  ### 1. 보안상의 치명적인 한계
  클라이언트(사용자 브라우저)에 저장된다는 점
  1. 민감 정보 노출 및 변조 위험
     1. 문제: 쿠키는 사용자의 컴퓨터에 파일 형태로 저장되거나, 개발자 도구를 통해 쉽게 접근 및 조작될 수 있음
     2. 결과: 만약 쿠키에 사용자 이름이나 중요 권한같은 민감한 정보를 직접 저장해 놓으면, 해커나 악의적인 사용자가 그 값을 쉽게 읽거나 변조하여 권한을 탈취할 수 있음
        1. 예시: 만약 쿠키에 isAdmin=false 라는 정보가 있다면 isAdmin=true 로 바꿔 권리자 권한을 얻으려 시도할 수 있음
  2. 탈취 위험 (XSS 공격)
     1. 문제: 악성 스크립트를 웹사이트에 삽입하는 XSS공격에 취약할 수 있음
     2. 결과: 해커가 사용자의 쿠키 정보를 훔쳐서 서버에 전송하면, 서버는 해커를 정상 사용자로 오인하고 인증을 허용하게 됨. 이 쿠키에 세션 ID같은 중요한 인증정보가 담겨있다면 보안 사고로 이어짐
  ***
  ### 2. 용량 및 성능상의 한계
  1. 저장 용량의 제한
     1. 문제: 쿠키는 브라우저마다 다르지만, 일반적으로 개당 4KB정도로 저장할 수 있는 데이터의 양이 매우 적음
     2. 결과: 로그인 상태나 선호 설정같은 간단한 정보만 저장할 수 있으며, 장바구니 목록이나 복잡한 사용자 상태 정보를 모두 저장하기에는 부족
  2. 네트워크 성능 저하 (매 요청 시 전송)
     1. 문제: 쿠키는 웹 브라우저가 서버에 요청을 보낼 때마다 해당 도메인에 설정된 모든 쿠키를 HTTP 헤더에 담아 전송
     2. 결과
        1. 저장된 쿠키의 양이 많을수록 전송 데이터 크기가 커져 네트워크 부하가 증가, 전송 속도 느려져 성능이 저하될 수 있음
        2. 서버 입장에서는 요청을 처리할 때마다 불필요하게 큰 쿠키데이터를 매번 받아야함
  ***
  ### 3. 쿠키의 한계 극복 방법
  쿠키는 사용자 식별자(세션 ID)를 저장하는 용도로만 사용하고, 실제 중요한 정보는 서버에 저장하여 관리하는 방식 사용

📚 블로그 읽고 XSS(Cross-SIte Scripting) 정리해보기! 🍠

- XSS 공격은 무엇인가요?
  : 공격자가 악성 스크립트를 웹사이트에 삽입하여, 그 웹사이트를 이용하는 다른 사용자(클라이언트)의 브라우저에서 스크립트가 실행되도록 유도하는 해킹 기법
  **공격의 목표**
  피해자(사용자)의 세션 쿠키나 로컬 스토리지에 저장된 정보를 훔치는 것
  이 정보에는 종종 로그인 상태를 유지하는 세션ID나 액세스 토큰이 포함되어 있어, 이를 탈취하면 해커가 피해자인 것처럼 서버에 요청을 보낼 수 있게 됨
  **공격의 과정**
  1. 악성 스크립트 주입: 공격자가 웹사이트의 입력 필드(게시판, 댓글, 검색창 등)에 <script> 태그를 포함한 악성 코드를 삽입
  2. 서버 저장/전달: 이 악성 코드는 서버에 저장되거나(저장형 XSS), URL을 통해 전달됨(반사형 XSS)
  3. 피해자 실행: 다른 사용자가 이 악성코드가 포함된 페이지를 방문하면 웹 브라우저는 이 코드가 웹사이트의 일부라고 생각하고 악성 스크립트를 실행
  4. 정보 탈취: 실행된 스크립트는 피해자의 쿠키 정보를 훔치거나, 사용자를 가짜 사이트로 이동시키거나, 사용자의 화면을 조작하는 등의 행위를 함
  ***
  ### XSS 공격의 세 가지 주요 유형
  1. 저장형 XSS
     1. 악성 스크립트가 서버의 데이터베이스에 영구적으로 저장됨
     2. 피해자가 해당 콘텐츠를 조회할 때마다 스크립트가 실행됨(제일 위험)
     3. 예) 게시판 댓글, 사용자 프로필, 메시지 등에 악성 스크립트 저장됨
  2. 반사형 XSS
     1. 악성 스크립트가 URL의 쿼리 파라미터 등을 통해 서버에 전달됨
     2. 서버가 이를 즉시 응답 페이지에 포함하여 반사함
     3. 예) 검색 결과 페이지의 URL에 악성 스크립트를 넣어 피해자에게 전송하고, 피해자가 그 링크를 클릭하면 실행됨
  3. DOM 기반 XSS
     1. 스크립트가 서버를 거치지 않고, 오직 브라우저(DOM 환경) 내에서 실행됨
     2. 주로 JavaScript 코드가 사용자 입력을 받아 DOM(문서 객체 모델)을 조작할 때 발생
     3. 예) URL의 일부 값을 JavaScript 코드가 직접 읽어와서 페이지 내용에 삽입할 때 발생
- XSS 방어 전략에 대해 정리해주세요.
  사용자로부터 입력받은 모든 데이터를 신뢰하지 않는 것.

  1. 입력 값 검증 및 무력화

     사용자로부터 입력받는 모든 데이터에 대해 실행 가능한 코드가 포함되어 있는지 확인하고 처리하는 과정

     - HTML 엔티티 변환(Escaping): <나 >같은 특수 문자를 브라우저가 태그(Tag)로 인식하지 못하도록 문자열 그대로 인식하게 바꾸는 것이 중요
       - <(꺽쇠 괄호)를 &lt; 로 변환. 브라우저는 이것을 일반적인 텍스트로만 표시하고 코드로 실행하지 않음
     - 화이트리스트 기반 필터링(Sanitization): 사용자 입력에서 허용해야 할 태그와 속성만(<b>,<img> 등)을 지정하고, 그 외의 모든 태그(특히 <script>나 <iframe>)는 제거하거나 변환함(블랙리스트 방식은 우회될 가능성이 높으므로 지양해야함)

  2. 쿠키 보안 강화(HttpOnly)

     쿠키를 통해 세션 정보가 탈취되는 것을 막는 가장 효과적인 방법

     - HttpOnly 속성 사용: 중요한 세션ID나 토큰을 담는 쿠키에 HttpOnly 속성 설정
       - 효과: 클라이언트 측의 JavaScript 코드가 해당 쿠키에 접근하는 것을 막아줌→악성 스크립트가 실행되더라도 쿠키 정보 탈취를 시도조차 할 수 없게됨

  3. 콘텐츠 보안 정책(CSP: Content Security Policy) 적용

     브라우저에게 ‘어떤 종류의 콘텐츠(스크립트, 스타일, 이미지 등)를 어디에서 불러와야 안전한지’ 알려주는 규칙을 서버가 설정하는 방식

     - 역할: CSP는 신뢰할 수 없는 출처(Origin)의 스크립트 실행을 차단하고, eval()같은 위험한 JavaScript 함수 사용을 제한해 XSS 공격의 실행 자체를 원천적으로 봉쇄
       - 예: “이 웹사이트는 오직 우리 도메인에서 온 스크립트만 실행할 수 있어!”라고 선언

📚 블로그 읽고 세션 하이재킹 정리해보기

- 세션 하이재킹은 무엇인가요? 🍠
  공격자가 사용자와 서버 사이에 이미 수립된 ‘세션(Session)’을 가로채서, 정상 사용자인 것처럼 행세하며 권한 도용하는 해킹 기법
  쉽게 말해, 은행 거래를 하고 있는 VIP 고객의 신분증(세션ID)을 몰래 훔쳐서, 본인인 척 은행 서비스를 이용하는 것
  ***
  **하이재킹의 원리**
  세션 ID만 확보하면, 공격자는 서버에게 “나도 이 세션ID를 가지고 있어”라고 속여 정상 사용자의 모든 권한을 획득할 수 있음
  **공격의 주요 결과**
  - 권한 도용: 공격자가 피해자의 계정으로 쇼핑, 금융거래, 정보 변경 등 모든 작업을 수행할 수 있음
  - 정보 탈취: 피해자의 개인정보나 민감한 데이터를 열람할 수 있음
  ***
  ### 주요 공격 과정
  1. 네트워크 스니핑
     1. 개념: 공격자가 동일 네트워크(공용 Wi-Fi망)에 접속하여, 데이터 통신을 가로채는 방식
     2. 과정
        1. 사용자가 웹사이트와 통신하며 세션 ID가 담긴 쿠키 주고받음
        2. 공격자는 네트워크를 감시하여 암호화되지 않은(HTTP)통신에서 이 세션ID를 포함한 패킷(데이터 덩어리)을 낚아챔
        3. 탈취한 세션 ID를 자신의 브라우저에 넣어 접속하면, 서버는 공격자를 정상 사용자로 인식함
  2. XSS 공격을 통한 쿠키 탈취
     1. 개념: XSS(Cross-Site Scripting) 공격을 이용하여 쿠키에 접근하는 방식
     2. 과정
        1. 공격자가 웹사이트에 악성 스크립트를 삽입
        2. 피해자가 이 페이지에 접속하여 스크립트가 실행됨
        3. 실행된 스크립트가 피해자의 브라우저에 저장된 세션 ID를 훔쳐(읽어서), 공격자 서버로 몰래 전송
        4. 공격자는 이 세션 ID를 사용하여 권한 도용
- XSS 공격을 차단하는 방법은 무엇인가요? 🍠
  세션 ID의 탈취 자체를 어렵게 만들고, 탈취되더라도 사용을 무력화하는 방어책이 필요
  1. 통신 암호화(가장 중요)
     1. HTTPS 의무화: 모든 통신에 SSL/TLS 암호화를 적용한 HTTPS를 사용해야함
     2. 효과: 통신 내용이 암호화되면, 공격자가 중간에서 패킷을 가로채더라도 세션 ID를 포함한 데이터의 내용을 해독할 수 없게됨(네트워크 스니핑 방어)
  2. 쿠키 보안 속성 사용
     1. HttpOnly 속성: 세션 ID가 담긴 쿠키에 이 속성을 설정하여, JavaScript를 통한 쿠키 접근(읽기)을 원천적으로 차단
  3. 세션 ID 무효화 및 재발급
     1. 로그인/권한 변경 시 재발급: 사용자가 로그인하거나 비밀번호 변경 등 민감한 권한 변경을 시도할 때마다 세션 ID를 새로 발급하여 이전의 세션 ID 무효화
     2. 효과: 만약 공격자가 이전 세션 ID를 훔쳤더라도, 사용자가 로그인을 완료하면 그 ID는 무용지물이 됨
  4. 세션 타임아웃 및 IP 검사
     1. 짧은 만료기간: 세션 ID의 유효기간 짧게 설정→ 탈취되더라도 공격자가 사용할 수 있는 시간을 최소화
     2. IP 주소 검사: 서버는 세션 ID를 보낸 클라이언트의 IP 주소를 함께 기록하고, 이후 요청에서 IP 주소가 갑자기 변경되었을 경우 세션을 강제 종료하도록 설정
- 쿠키의 다양한 옵션들에 대해서 정리해주세요. 🍠
  ### 유효기간 및 생명 주기 제어 옵션
  쿠키가 언제까지 살아있을지 결정
  1. `Expires`
     1. 역할: 쿠키가 삭제될 정확한 날짜와 시간 지정
     2. 설정: `Set-Cookie: name=value; Expires=Wed, 21 Oct 2025 07:28:00 GMT`
     3. 특징: 해당 쿠키는 영속적 쿠키가 되어, 브라우저를 닫아도 지정된 만료 날짜까지 사용자 컴퓨터에 저장됨
  2. `Max-Age`
     1. 역할: 쿠키가 생성된 시점부터 몇 초 동안 유효할지 지정
     2. 설정: `Set-Cookie: name=value; Max-Age=3600` (3600초, 즉 1시간 유효)
     3. 특징: Expires와 동일하게 영속적 쿠키를 만드는 속성.
        1. 상대적인 시간을 사용하기 때문에 서버의 시간 설정에 영향을 받지 않아 더 선호됨
  ***
  ### 접근 범위 제어 옵션
  어떤 도메인과 어떤 경로에서 쿠키를 사용할 수 있을지 결정
  1. `Domain`
     1. 역할: 쿠키가 유효한 도메인 범위 지정
     2. 설정: `Set-Cookie: name=value; [Domain=example.com](http://domain=example.com/)`
     3. 특징: `example.com`과 모든 하위 도메인(`www.example.com`, `blog.example.com` 등)에서 사용할 수 있음
        1. 이 설정을 통해 서비스 전체에서 쿠키를 공유할 수 있음
  2. `Path`
     1. 역할: 쿠키가 유효한 웹사이트의 특정 경로(디렉토리)를 지정
     2. 설정: `Set-Cookie: name=value; Path=/admin`
     3. 특징: `/admin` 경로와 그 하위 경로(`/admin/users`, `/admin/settings` 등)로 요청을 보낼 때만 전송됨.
        1. 기본 값은 `/`로, 도메인 전체에서 유효하도록 설정되는 경우가 많음
  ***
  ### 보안 강화 옵션⭐️⭐️⭐️
  쿠키가 탈취되거나 오용되는 것을 막아 보안을 강화하는 데 핵심적인 역할
  1. `Secure`
     1. 역할: 쿠키가 HTTPS(암호화된 연결)를 통해서만 전송되도록 강제
     2. 설정: `Set-Cookie: name=value; Secure` (값 없이 속성명만 추가)
     3. 특징:
        1. 사용자가 일반 HTTP(암호화되지 않은)로 접속했을 때는 쿠키가 전송되지 않음.
        2. 중간자 공격(MITM)을 막아 네트워크를 통한 쿠키 탈취 위험을 크게 줄여줌
  2. `HttpOnly`
     1. 역할: JavaScript를 통한 쿠키 접근을 완벽하게 차단
     2. 설정: `Set-Cookie: name=value; HttpOnly`
     3. 특징:
        1. 브라우저의 `document.cookie` API로 읽거나 수정할 수 없음
        2. XSS 공격을 통해 세션 ID를 탈취하는 것을 가장 효과적인 방어수단
        3. 서버와 HTTP 통신할 때만 사용 가능
  3. `SameSite`
     1. 역할: 웹사이트 간 요청(Cross-Site Request)시 쿠키 전송 여부를 제어→CSRF 공격을 방지하는 데 사용
     2. 설정: `Set-Cookie: name=value; SameSite=Strict` 또는 `Lax` 또는 `None`
        1. Strict: 가장 엄격한 설정. 외부 사이트에서 우리 사이트로 요청이 올 때 쿠키를 전송하지 않음
        2. Lax: 기본 설정값(최신 브라우저). 외부 링크를 통해 GET 요청으로 접속할 때만 쿠키를 전송하고, POST 요청 등 다른 경우는 차단함
        3. None: 외부 사이트에서 요청이 올 때도 쿠키를 전송. 단, 이 경우 반드시 Secure 속성과 함께 사용해야함
     3. 중요성: 오늘날 CSRF 공격 방어를 위한 가장 중요한 쿠키 옵션 중 하나로 널리 사용됨

📚 블로그 읽고 CSRF 공격 정리해보기

- CSRF는 무엇인가요? 🍠
  사용자가 의도하지 않은 요청(요청 위조)을 강제로 보내게 하여, 사용자가 로그인된 웹사이트에서 특정 행위를 실행하게 만드는 해킹 기법
  쉽게 말해, 로그인된 사용자의 ‘신분’을 도용→악성행위 시키는 것
  **공격의 원리**
  사용자가 웹사이트에 로그인하여 유효한 세션(인증상태)을 유지하고 있다는 점을 악용
  1. 사용자 로그인: 피해자(A)가 은행 웹사이트(예: bank.com)에 로그인하여 유효한 세션 쿠키를 브라우저에 가지고 있음
  2. 공격 유도: 공격자(B)가 악성코드가 삽입된 웹사이트나 이메일(예: `bob-malicious.com`)을 만들어 A가 방문하도록 유도함
  3. 위조된 요청 전송: A가 악성 페이지를 방문하는 순간, 그 페이지에 숨겨진 코드가 A의 브라우저를 강제로 이용하여 bank.com으로 요청을 보냄
     - 예: 100만원을 B의 계좌로 이체하는 POST 요청 또는 이미지 로딩을 위장한 GET 요청
  4. 서버 실행: A의 브라우저는 bank.com으로 요청을 보낼 때, 이전에 로그인하면서 받았던 유효한 세션 쿠키를 자동으로 첨부
  5. 피해 발생: [bank.com](http://bank.com) 서버는 이 요청이 A의 브라우저에서 A의 유효한 쿠키와 함께 왔기 때문에 정상적인 요청이라고 판단하고, B에게 100만원을 이체하는 등의 악성 행위 실행
     핵심: 서버는 ‘**누가**’ 요청했는지(유효한 쿠키를 가진 사용자)만 확인하고 ‘요청자가 정말로 이 행위를 원했는지’는 확인하지 않는다는 취약점을 노린 공격
- CSRF 방어 전략에 대해 정리해주세요. 🍠
  핵심: **“요청을 보낸 사용자가 그 요청을 의도한 것이 맞는지”**를 서버가 확인하도록 하는 것
  1. SamSite 쿠키 속성 사용 (가장 기본적이고 효과적)
     1. 원리: 브라우저에게 “외부(다른 도메인)에서 들어온 요청에는 쿠키를 자동으로 첨부하지 말라”고 지시
     2. 설정: 중요한 인증 쿠키에 `SameSite=Strict` 또는 `SameSite=Lax` 설정
        1. `Lax`는 외부 사이트에서 단순 링크 클릭(GET 요청)으로 들어오는 경우는 허용하지만, CSRF 공격에 주로 사용되는 POST 요청 등은 차단하여 실용적이면서도 높은 방어 효과를 제공
  2. CSRF 토큰(Token) 사용 (가장 확실한 방어)
     1. 원리: 사용자가 요청을 보낼 때마다 서버가 예측할 수 없는 일회용 비밀 토큰을 생성하여 함께 검증하는 방식
  3. Referer 검증
     1. 원리: HTTP 요청 헤더에 있는 Referer(이전 페이지 주소)를 확인하여, 요청이 우리 웹사이트(동일 도메인)에서 시작된 것인지 확인
     2. 한계: 일부 브라우저 설정이나 네트워크 환경에서는 Referer 헤더가 생략될 수 있으며, 완벽한 방어 수단은 아님
  4. Captcha(캡챠) 등 재인증
     1. 원리: 계좌이체, 비밀번호 변경 등 민감한 작업 직전에 사용자의 비밀번호 재확인이나 캡챠 인증을 요구하여 강제적인 자동 요청을 막음
     2. 한계: 사용자 경험(UX)을 저해할 수 있어 모든 요청에 적용하기는 어려움
- CSRF 토큰의 장점과 단점에 대해 정리해주세요. 🍠
  **CSRF 토큰 작동 원리**
  1. **서버 발급:** 사용자가 페이지를 요청하면, 서버는 **무작위의 일회용 비밀 토큰**을 생성하여 사용자에게 전달. (토큰은 보통 숨겨진 필드 `<input type="hidden">`에 포함되거나 헤더에 담김)
  2. **클라이언트 저장:** 브라우저는 이 토큰을 저장
  3. **요청 시 첨부:** 사용자가 폼을 전송하거나 서버에 요청을 보낼 때, 브라우저는 이 **CSRF 토큰**을 요청 데이터에 포함하여 서버로 보냄
  4. **서버 검증:** 서버는 요청이 올 때마다, 이 **전달받은 토큰**과 **서버가 세션에 저장해 둔 원본 토큰**이 **일치하는지 확인**
     - **공격의 실패:** 공격자가 요청을 위조하더라도 **이 비밀 토큰 값을 알 수 없기 때문에**, 서버에서 요청이 위조된 것으로 판단하여 차단
  ***
  **장점**
  - 높은 방어력: 서버가 요청의 출처와 의도를 직접 검증하므로, 토큰이 유출되지 않는 한 CSRF 공격을 매우 효과적으로 차단
  - 명시적인 검증: 요청 위조여부를 명확히 판단할 수 있음
  ***
  **단점**
  - 복잡한 구현: 서버와 클라이언트 모두 토큰 생성, 저장, 전송, 검증 로직을 추가해야 하므로 개발 비용과 복잡성 증가
  - 성능 부하: 토큰을 생성하고, 서버 세션에 저장하고, 매 요청마다 비교해야 하므로 서버에 약간의 처리 부하 발생
  - 상태 유지(Stateful): 토큰을 서버 세션에 저장해야 하므로, 서버의 상태를 유지해야함. →서버를 여러 대로 확장할 때 토큰 공유 문제를 발생시킬 수 있음
- CAPTCHA(캡챠)는 무엇인가요? 🍠

  사용자가 실제 사람인지, 아니면 자동으로 작동하는 컴퓨터 프로그램(봇)인지를 구별하기 위해 고안된 테스트

  쉽게 말해, 기계는 풀기 어렵지만 사람은 쉽게 통과할 수 있는 ‘인증 시험’

  사람이 가진 특유의 인지 능력(흐릿한 글씨 읽기, 이미지 구별하기, 맥락 이해하기 등)을 시험하여 봇을 걸러냄

- 쿠키 방식으로 인증 정보를 전송할 때 브라우저가 자동으로 쿠키를 포함하는 조건은 무엇인가요? 🍠
  쿠키에 설정된 여러 옵션(속성)들이 현재 서버로 보내는 요청 정보와 일치할 때
  ### 전송범위 조건(Domain 및 Path)
  브라우저는 쿠키를 설정할 때 지정된 도메인과 경로가 현재 요청의 URL과 일치하는지 확인한다
  1. Domain(도메인 일치)
     - 쿠키에 설정된 Domain 속성이 현재 요청을 보내는 서버의 도메인과 일치하거나, 쿠키의 Domain이 요청 도메인의 상위 도메인일 경우 전송됨
     - 예: 쿠키에 Domain=example.com으로 설정되어 있다면, example.com, www.example.com, [blog.example.com](http://blog.example.com) 등 모든 하위 도메인으로의 요청에 쿠키가 포함됨
  2. Path(경로 일치)
     - 쿠키에 설정된 Path 속성이 현재 요청의 URL 경로보다 상위 경로이거나 일치하는 경우에 전송됨
       - 예: 쿠키에 Path=/admin 으로 설정되어 있으면, /admin, /admin/users, /admin/settings 등으로의 요청에는 포함되지만, /home으로는 전송되지 않음
  ### 보안 조건(Secure 및 SameSite)
  쿠키에 설정된 보안 속성들이 현재 요청의 통신 방식과 일치하는지 확인
  1. Secure(HTTPS 프로토콜)
     - 쿠키에 Secure 속성이 설정되어 있으면, 브라우저는 현재 요청이 HTTPS(암호화된 연결)를 통해서 이루어질 때만 쿠키를 전송
       - 주의: HTTP(암호화되지 않은 연결) 요청에는 절대 포함X
  2. SameSite (요청 출처 일치)
     - 쿠키에 설정된 SameSite 속성(예: Strict, Lax, None)에 따라 외부(다른 웹사이트)에서 우리 서버로 요청이 들어올 때 쿠키 전송 여부가 결정됨
       - SameSite=Strict: 현재 브라우저의 URL 도메인과 **완벽하게 동일한 요청**에서만 쿠키를 전송
       - 외부 링크를 통한 접속시에는 쿠키를 전송하지 않아 CSRF 공격 방어에 가장 강력
     - SameSite=Lax: 외부 링크를 통한 GET 요청에서는 전송을 허용하지만 POST 요청 등 데이터 변경이 가능한 요청에는 전송하지 않음 (최신 브라우저의 기본값)
- 크로스 도메인 환경에서 쿠키를 전송하려면 서버와 클라이언트 측에서 각각 어떤 설정이 필요할까요? 🍠
  서버와 클라이언트 양쪽에서 추가 설정 필요
  **🧑‍💻서버 측 설정:**
  CORS 설정에서 allowCredentials 를 true로 설정
  credentials를 허용하면 보안상의 이유로 Access-Control-Allow-Origin에 **와일드카드(_)를 사용할 수 없음_**
  ⇒반드시 **특정 도메인 명시**!!
  **👩‍💻클라이언트 측 설정:**
  크로스 도메인에서는 쿠키가 자동으로 전송되지 않음
  개발자가 “이 요청에는 쿠키를 포함시켜달라”고 브라우저에게 알려야함
  클라이언트에서는
  fetch API를 사용한다면 → credentials:’include’ 옵션
  axios 사용한다면 → withCredentials: true 설정 추가
- 쿠키 기반 인증에서 CSRF 공격이 발생할 수 있는 원리는 무엇인가요? 🍠
  **공격의 원리**
  사용자가 웹사이트에 로그인하여 유효한 세션(인증상태)을 유지하고 있다는 점을 악용

  1. 사용자 로그인: 피해자(A)가 은행 웹사이트(예: bank.com)에 로그인하여 유효한 세션 쿠키를 브라우저에 가지고 있음
  2. 공격 유도: 공격자(B)가 악성코드가 삽입된 웹사이트나 이메일(예: `bob-malicious.com`)을 만들어 A가 방문하도록 유도함
  3. 위조된 요청 전송: A가 악성 페이지를 방문하는 순간, 그 페이지에 숨겨진 코드가 A의 브라우저를 강제로 이용하여 bank.com으로 요청을 보냄
     - 예: 100만원을 B의 계좌로 이체하는 POST 요청 또는 이미지 로딩을 위장한 GET 요청
  4. 서버 실행: A의 브라우저는 bank.com으로 요청을 보낼 때, 이전에 로그인하면서 받았던 유효한 세션 쿠키를 자동으로 첨부
  5. 피해 발생: [bank.com](http://bank.com) 서버는 이 요청이 A의 브라우저에서 A의 유효한 쿠키와 함께 왔기 때문에 정상적인 요청이라고 판단하고, B에게 100만원을 이체하는 등의 악성 행위 실행
  핵심: 서버는 ‘**누가**’ 요청했는지(유효한 쿠키를 가진 사용자)만 확인하고 ‘요청자가 정말로 이 행위를 원했는지’는 확인하지 않는다는 취약점을 노린 공격
    <aside>
    🏦

  예시:

  은행 사이트([bank.com](http://bank.com/))에 로그인한 상태에서 악성 사이트([bad.com](http://bad.com/))를 방문했다고 생각해보겠습니다. 만약 브라우저가 크로스 도메인 요청에도 자동으로 쿠키를 포함시킨다면, bad.com의 JavaScript 코드가 bank.com으로 송금 요청을 보낼 때 여러분의 인증 쿠키가 자동으로 포함되어 실제로 송금이 일어날 수 있습니다.

    </aside>

- 헤더 방식 인증의 주요 장점(예: CSRF 방어, 선택적 전송, CORS 단순화)을 정리해주세요. 🍠
  **헤더 방식**: HTTP 헤더를 통한 인증은 **개발자가 완전한 제어권**을 갖는 방식.
  **언제 토큰을 전송할지**, **어떤 요청에 포함시킬지**를 **개발자가 직접 결정**
  브라우저가 자동으로 해주는 것 아무것도 없음
  가장 널리 사용되는 것: Authorization 헤더에 Bearer 토큰을 담아 보내는 방식
  ***
  **장점**
  - CSRF 공격 원천 차단: 악성 사이트가 요청을 보내도 토큰을 모르기 때문에 인증 불가
  - 선택적 전송: 인증이 필요 없는 요청에는 토큰을 보내지 않아 네트워크 효율성 향상
  - CORS 단순화: credetials 설정이 필요 없어 와일드카드(\*) 사용 가능
- 토큰을 클라이언트에 저장할 때 LocalStorage, SessionStorage, 메모리 저장의 장단점을 비교해주세요. 🍠
  **토큰을 클라이언트(브라우저) 어디에 저장할 것인가**
  즉, JWT 토큰은 이미 서버에서 발급됐고, 이걸 브라우저 어디에 보관했다가 요청할 때마다 꺼내서 헤더에 넣을지 결정하는 것.
    <aside>
    🏦
    
    **브라우저 저장소**
    
    - LocalStorage
        - 가장 편리하지만 XSS 공격에 완전히 노출됨
        - 악성 스크립트가 실행되면 localStorage.getItem(’token’)으로 토큰을 읽어갈 수 있음
        - 브라우저를 닫아도 데이터가 유지되지만, 그만큼 위험도 지속됨
        - 영구저장이 필요하고 XSS 위험을 다른 방법으로 완벽히 통제할 수 있는 경우에만 고려해야함
    - SessionStorage
        - 브라우저 탭이 닫히면 자동으로 삭제되므로 LocalStorage보다는 안전하지만, 여전히 XSS에 취약
        - 새 탭에서는 다시 로그인해야하는 불편함 있음
    - 메모리 저장
        - 가장 안전한 방법
        - JavaScript 변수나 React 상태로 관리하면 XSS 공격이 발생하더라도 토큰에 직접 접근하기 어려움
        - 단점: 페이지 새로고침 시 토큰이 사라진다
            - 이는 Refresh Token을 HttpOnly 쿠키로 저장하는 방식으로 해결할 수 있음
    </aside>
    
    쿠키 방식과 달리 헤더 방식은 브라우저가 자동으로 관리해주지 않음
    
    개발자가 선택해야함
    
    → 서비스의 특성과 환경에 맞게 최적의 선택을 해줘야함
    
    쿠키와 헤더 방식 중 무엇이 더 나은지는 상황에 따라 다르다. 
    
    **쿠키**는 브라우저가 자동 관리해주어 편리하지만, 크로스 도메인 환경에서는 설정이 복잡하고 CSRF 공격에 주의해야 한다. 
    
    **헤더**는 명시적 제어가 가능하고 CSRF 걱정이 없지만, 토큰 저장과 관리를 개발자가 직접 구현해야 한다.
    
    각 방식의 장단점을 이해하고 서비스의 요구사항에 맞는 선택을 해야한다. 
    
    서비스가 성장하면서 필요에 따라 전략을 수정해나가기도 한다는 점도 인지하고 유연성 있는 설계를 하는 것도 좋을 것 같다.

- Single Page Application, Mobile Application, Server Side Rendering Application 에서 여러분들이 생각하는 적합한 인증 전략은 무엇이라고 생각하시나요? 🍠
  각각 특성과 보안 요구사항이 다르므로, 적합한 인증 전략 또한 달라짐
  ***
  ## 1. Single Page Application (SPA)
  SPA는 페이지 전체를 새로고침하지 않고 클라이언트(브라우저) 측에서 동적으로 콘텐츠를 렌더링
  ### 적합한 인증 전략: 토큰 기반 인증 (JWT)
  | 전략                   | 설명                                                                                                                                                                   | 이유                                                                                                                           |
  | ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
  | **액세스 토큰 (JWT)**  | 로그인 성공 시 서버가 **Access Token**을 발행하고, 클라이언트는 이를 **로컬 스토리지 또는 메모리**에 저장한 후 API 요청 시 **Authorization 헤더**에 첨부하여 보냅니다. | **Stateless(무상태성):** SPA는 API 서버와 분리되어 있어, 세션처럼 서버에 상태를 저장할 필요가 없어 서버 확장에 유리합니다.     |
  | **Refresh Token 병행** | 액세스 토큰의 짧은 만료 기간을 보완하기 위해, 유효 기간이 긴 Refresh Token을 사용하여 새 Access Token을 발급받습니다.                                                  | **보안 및 사용자 경험:** Access Token을 짧게 가져가 보안을 강화하고, Refresh Token으로 재로그인 없이 사용자 경험을 유지합니다. |
  ### ⚠️ 주의 사항 (보안 문제)
  - **로컬 스토리지의 위험:** JWT를 로컬 스토리지에 저장하면 **XSS 공격**에 취약하여 토큰이 쉽게 탈취될 수 있습니다.
  - **권장 방안:** CSRF 공격을 막기 위해 **SameSite 속성이 Strict로 설정된 HttpOnly 쿠키**에 Refresh Token을 저장하고, Access Token은 메모리에 저장하여 XSS 노출을 최소화하는 방식이 가장 안전한 방법으로 권장됩니다.
  ***
  ## 2. Mobile Application
  모바일 앱은 브라우저 환경이 아니며, 데이터 저장을 **모바일 기기의 전용 저장소**에 합니다.
  ### 적합한 인증 전략: 토큰 기반 인증 (JWT) + Secure Storage
  | 전략                     | 설명                                                                                 | 이유                                                                                                                           |
  | ------------------------ | ------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
  | **토큰 기반 인증 (JWT)** | SPA와 마찬가지로 Access Token과 Refresh Token을 사용합니다.                          | **API 통신 표준:** 모바일 앱은 기본적으로 API 서버와 통신하며, 가장 표준적이고 유연한 인증 방식입니다.                         |
  | **Secure Storage 사용**  | 토큰을 **안전한 저장 공간** (iOS의 KeyChain, Android의 Keystore)에 저장합니다.       | **최고의 보안:** 모바일 기기의 보안 기능을 활용하여 일반 로컬 스토리지보다 훨씬 강력하게 토큰을 보호하여 탈취 위험을 낮춥니다. |
  | **생체 인증 연동**       | Touch ID나 Face ID 같은 생체 인증과 연동하여 사용자 편의성과 보안을 동시에 높입니다. | **편의성:** 사용자 경험을 개선하고, 앱을 실행할 때마다 비밀번호를 입력하는 불편함을 해소합니다.                                |
  ***
  ## 3. Server Side Rendering (SSR) Application
  SSR은 웹 페이지의 렌더링을 주로 서버에서 처리하며, 전통적인 웹 환경과 유사합니다.
  ### 적합한 인증 전략: 서버 세션 기반 인증
  | 전략                                | 설명                                                                                                                                              | 이유                                                                                                                |
  | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
  | **서버 세션 (Session ID + Cookie)** | 사용자가 로그인하면 서버가 세션 ID를 발급하고, 이 ID를 쿠키에 담아 클라이언트에게 전송합니다. 실제 사용자 정보는 **서버 메모리/DB**에 저장됩니다. | **전통적인 안정성:** 서버에서 모든 렌더링과 상태 관리를 하므로, 서버 세션 방식이 가장 구현이 간단하고 안정적입니다. |
  | **`HttpOnly` 쿠키 사용**            | 세션 ID가 담긴 쿠키에 반드시 **`HttpOnly`** 속성을 설정합니다.                                                                                    | **XSS 방어:** 쿠키가 JavaScript로 접근되는 것을 막아 세션 ID 탈취를 방지합니다.                                     |
  | **CSRF 토큰 병행**                  | 중요한 요청(폼 제출 등)에 **CSRF 토큰**을 사용하여 요청의 의도성을 확인합니다.                                                                    | **CSRF 방어:** 세션 기반 인증은 CSRF에 취약하므로, 토큰을 통해 요청 위조를 차단합니다.                              |
  ### ⚠️ 주의 사항 (확장성 문제)
  - **서버 부하:** 사용자가 늘어날수록 세션 정보를 저장하는 서버 메모리나 DB에 부하가 발생합니다.
  - **Scale Out 문제:** 여러 대의 서버를 운영할 경우, 세션 정보를 공유(세션 클러스터링)하는 복잡한 시스템 구성이 필요합니다.
