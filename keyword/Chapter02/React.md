## React 개요

- React는 **UI 그리는 일에 특화된 라이브러리**.
- **Virtual DOM + Diff**를 사용해 **최소한의 DOM 변경**만 수행.
- **동시성 렌더링 / 배칭 / Suspense**로 화면을 **부드럽고 똑똑하게 업데이트**.
- **React 19**는 다음과 같은 개선을 통해 **일상 개발 품질을 크게 향상**:
  - Suspense 체감 개선
  - `ref` as prop 지원
  - 액션 & 폼 개선
  - JSX 트랜스폼 요구

---

## useState 기초

`useState`는 함수형 컴포넌트 안에서 **상태(state)**를 정의하고 관리할 수 있게 해주는 훅.

- `useState`는 **배열**을 반환.
  - 첫 번째 원소: **현재 상태 값(state)**
  - 두 번째 원소: **상태를 변경하는 함수(setState)**
- `state`는 처음엔 `useState`의 괄호 안에 넣어준 **초기값**을 그대로 가짐.
- `setState`를 호출하면 상태 값이 바뀌고, **상태가 바뀌면 React는 컴포넌트를 다시 렌더링**.

## 얕은 복사

얕은 복사는 **한 단계까지만 복사**하는 방식.
복사된 객체는 원본 객체와 내부 참조를 공유하기 때문에, 중첩 객체가 있다면 원본도 같이 바뀔 수 있음.

## 깊은 복사

깊은 복사는 **중첩된 값까지 전부 새로운 복사본**을 만드는 방식.
복사본을 수정해도 원본 객체에는 영향을 주지는 않음.

- 장점: 원본과 완전히 독립된 객체가 생성됨
- 단점: `undefined`, 함수 같은 값은 복사되지 않음 → 안전하게 쓰려면 `lodash.cloneDeep` 같은 라이브러리를 사용 권장.

---

## Lazy Initialization

**Lazy Initialization**은 `useState`의 초기값을 계산하는 함수가 **처음 렌더링에서만 실행**되고, 이후에는 다시 실행되지 않는 방식.

### 장점

- 계산 비용이 큰 함수를 한 번만 실행하므로 성능이 좋아짐
- 필요한 시점에만 초기 계산을 지연시킬 수 있음

👉 사용법: `useState(() => 함수명())` or `useState(함수명)`

---

## 몰랐던 개념 - React에서 상태(State)의 필요성

React에서는 **“상태(state)”**가 핵심 요인.
단순한 변수는 값이 바뀌어도 **렌더링을 다시 일으키지 않기 때문에** 화면에 반영되지 않음.

```tsx
function App() {
  let cnt = 0;
  const countUp = () => {
    cnt++;
  };

  return (
    <>
      <h1>{cnt}</h1>
      <button onClick={countUp}>증가</button>
    </>
  );
}
```

변수 `cnt`는 `countUp` 함수 실행 시 계속 증가하지만, **렌더링이 일어나지 않기 때문에 화면에는 여전히 0만 표시**.

즉, 값은 바뀌지만 UI에 반영되지 않음.

👉 React에서 화면을 다시 갱신하려면 **상태(state)를 변화**시켜야 한다.

---

## props drilling 문제점 이해하기

리액트에서 컴포넌트 간 데이터를 주고받는 기본적인 방법은 **props**.

그런데 컴포넌트 구조가 깊어지면, 실제로 필요하지 않은 컴포넌트까지 props를 억지로 내려줘야 하는 상황이 발생.

이것을 **props drilling**이라고 함.

## 1. props drilling이란?

부모 → 자식 → 손자 컴포넌트로 데이터를 전달하려면 props를 계속 내려줘야 함.

- 문제는 중간 컴포넌트가 그 데이터를 직접 쓰지 않더라도, 단순히 다음 컴포넌트로 전달하기 위해 props를 받아야 함.
- 이러한 방식은 불필요한 코드가 많아지고, 관리하기가 점점 어려워짐.

👉 이를 해결하기 위한 방법 중 하나인 **useContext**

## useContext란?

React의 `useContext`는 **전역 상태를 쉽게 공유**할 수 있도록 도와주는 Hook.

기존처럼 컴포넌트마다 일일이 props를 내려보내지 않아도, **여러 컴포넌트에서 같은 데이터를 바로 꺼내서 쓸 수 있음**.

또한 `useContext`는 단순히 전역 상태 관리뿐만 아니라, **의존성 주입(Dependency Injection, DI)** 역할도 함.

예를 들어, 공통적으로 쓰이는 API 클라이언트, 테마, 인증 정보 등을 **Context**로 감싸두면, 하위 컴포넌트 어디에서든 쉽게 주입받아 사용할 수 있음.

---
