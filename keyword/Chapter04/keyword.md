# 인증(Authentication)

사용자가 **자신의 신원을 증명하는 절차**.

## 개념

- “너는 누구니?”에 대한 확인 과정.
- 사용자가 주장한 신원이 실제로 맞는지 검증함.

## 방법

- 아이디 + 비밀번호 확인.
- OTP, 인증 코드, 생체인식 등 사용 가능.

## 목적

- 사용자가 실제 본인인지 확인할 수 있음.
- 다른 사람이 계정에 무단 접근하는 것을 방지할 수 있음.

---

# 인가(Authorization)

사용자가 **무엇을 할 수 있는지 결정하는 절차**.

## 개념

- “너는 무엇을 할 수 있니?”를 판단하는 과정.
- 인증이 끝난 사용자에게 **권한을 부여하거나 제한함**.
- 인증이 “너는 누구니?”라면, 인가는 “무엇을 할 수 있니?”에 해당함.

## 방법

- 사용자 역할(Role)에 따라 권한을 구분함.
- 접근 제어 목록(ACL), 정책 기반 접근 제어(PBAC) 등으로 관리 가능.
- 페이지, 기능, 데이터 접근 범위를 설정할 수 있음.

## 목적

- 사용자의 권한에 맞게 기능을 제한할 수 있음.
- 중요 정보에 대한 **무단 접근을 방지할 수 있음**.
- 시스템의 **보안성과 안정성을 유지할 수 있음**.

---

# JWT(JSON Web Token)

로그인한 사용자를 인증하기 위한 **서명된 토큰 기반 인증 방식**.

## 개념

- 사용자가 로그인 성공 시, 서버가 **서명된 토큰(AccessToken)** 을 발급함.
- 클라이언트는 이후 모든 요청에 **HTTP 헤더**로 토큰을 전달함.
- 서버는 토큰 안의 **서명, 만료 시간** 등을 검증함.
- 별도의 세션 저장 없이 인증 가능 → **무상태(stateless)** 인증 방식.

## 인증 흐름

1. 로그인 → AccessToken + RefreshToken 발급.
2. 요청 시 AccessToken 포함.
3. 만료 시 RefreshToken으로 재발급.
4. 로그아웃 시 토큰 삭제 및 무효화.

---

# 세션(Session)

## 개념

- 로그인 성공 시 서버가 **세션 ID** 생성 후 **저장소(메모리·Redis 등)** 에 저장.
- 클라이언트는 **세션 ID를 쿠키로 보관**.
- 요청마다 쿠키가 자동 전송되어 서버가 로그인 상태를 인식함.
- 서버가 상태(state)를 직접 관리하는 **유상태(stateful)** 인증 방식.

## 인증 흐름

1. 로그인 시 서버가 세션 ID 발급 → 쿠키로 전달.
2. 요청 시 쿠키 자동 포함 → 서버가 세션 확인.
3. 로그아웃 시 세션 삭제 → 즉시 만료 처리.
4. React 요청 시 `withCredentials: true` 설정 필요.

---

# 세션 방식 vs 토큰 방식

## 1. 세션(Session) 방식

- **원리**: 로그인 시 서버가 사용자 정보를 메모리에 저장하고, 세션 ID만 클라이언트 쿠키에 전달.
- **특징**:
  - 사용자 정보는 서버에 저장 → **정보 유출 위험 낮음**.
  - 접속자 증가 시 **서버 부하 및 확장성 문제 발생**.
  - 전통적인 로그인 유지 방식에 주로 사용됨.

## 2. 토큰(Token) 방식

- **원리**: 로그인 시 서버가 사용자 정보를 암호화한 **토큰(JWT)** 을 발급, 클라이언트가 직접 보관.
- **특징**:
  - **Stateless 구조**, 서버는 세션을 저장하지 않음.
  - **확장성·분산 환경에 유리**.
  - 토큰 탈취 시 악용 가능 → **보안 관리 중요**.
  - 토큰 크기가 커질 수 있어 **전송 비용 증가**.

➡️ 핵심 차이:  
**세션**은 사용자 정보를 서버에 저장,  
**토큰**은 사용자 정보를 토큰 내부에 포함시켜 클라이언트가 관리.

---

# 분산 환경의 세션 관리 3가지 전략

## 1. Sticky Session (세션 고정)

- **개념**: 같은 사용자의 요청을 항상 같은 서버로 전달.
- **장점**: 구현이 단순, 세션 동기화 불필요.
- **단점**: 특정 서버에 부하 집중, 서버 장애 시 세션 손실.

## 2. Session Replication (세션 복제)

- **개념**: 모든 서버가 세션 정보를 서로 복제·공유.
- **장점**: 서버 장애 시에도 세션 유지 가능.
- **단점**: 세션 동기화로 네트워크 부하 증가, 성능 저하 가능.

## 3. Centralized Session Store (중앙 세션 저장소)

- **개념**: 세션을 외부 저장소(Redis, Memcached 등)에 저장.
- **장점**: 세션 동기화 문제 해결, 스케일 아웃에 유리.
- **단점**: 중앙 저장소가 병목(SPOF) 가능, 관리 비용 발생.

---

# JWT (JSON Web Token) 장단점

## 개념

- **Self-contained 토큰**: 사용자 ID, 권한, 만료 시간 등을 포함.
- 서버의 비밀 키로 **서명**하여 위조·변조 방지.

## 장점

- **확장성 우수**: 여러 서버가 독립적으로 검증 가능.
- **MSA 환경**에서 인증 공유 용이.

## 단점

- **즉시 무효화 어려움** (만료 전까지 유효).
- 보안 이슈 발생 시 대응 지연.

---

# JWT 즉시 무효화 문제와 해결 방법

## 이유

- JWT는 Self-contained 구조로, 서버가 상태를 저장하지 않음.
- 로그아웃 후에도 **토큰 만료 전까지 계속 유효**.

## 해결 방법

1. **Access Token 짧게 발급**
2. **Refresh Token 사용 및 주기적 갱신**
3. **블랙리스트 관리로 강제 무효화**
4. **토큰 버전 관리(tokenVersion)** 로 이전 토큰 무효화

---

# 하이브리드 방식 (JWT + 저장소 메타데이터)

## 개념

- 로그인 시 서버가 **JWT 발급 + 토큰 메타데이터(DB/Redis 저장)**.
- 서버는 저장소에서 토큰 상태를 조회해 인증 처리.

## 장점

- **JWT의 확장성 + 세션의 제어력** 결합.
- **즉시 무효화 가능**, 중앙 저장소로 **상태 동기화 용이**.

## 단점

- **저장소 조회 필요** → 완전한 Stateless 아님.
- **중앙 저장소 관리 비용** 발생.

---

# 쿠키 (Cookie)

## 특징

- **브라우저가 자동으로 서버에 전송**

  - 같은 도메인 요청 시 브라우저가 알아서 쿠키를 붙여줌.

- **만료일 설정 가능** (`expires`, `max-age`)

- **도메인/경로 제한 가능**

- **보안 속성 제공**:
  - `HttpOnly`: JS에서 접근 불가 → XSS 방어
  - `Secure`: HTTPS 환경에서만 전송
  - `SameSite`: 크로스 도메인 요청에서 전송 여부 제어

---

# 배경 — HTTP가 무상태(Stateless)로 설계된 이유

- 1990년대 초, 웹은 **단순한 문서 전송**이 주 목적이었음.
- 수백만 명 동시 접속을 예상하지 못했음.
- 단순성과 확장성을 위해 **Stateless**하게 설계됨.

---

# HTTP 무상태성의 장단점

## 장점

- **확장성**: 서버 수평 확장 용이.
- **신뢰성**: 특정 서버 장애 시 다른 서버가 대체 가능.
- **단순성**: 서버가 클라이언트별 상태를 관리하지 않아 구현 단순.

## 단점

- 로그인 후 여러 페이지 이동 시 **로그인 상태 유지 필요**.
- 쇼핑몰 등에서 **장바구니 정보 유지 필요**.
- 회원가입 등 **다단계 프로세스에서 이전 입력값 보존 필요**.

---

# 쿠키의 Domain 디렉티브

## 개념

- **Domain 디렉티브**는 쿠키가 **어떤 도메인으로 전송될 수 있는지** 지정함.
- 기본적으로는 **쿠키를 발급한 도메인에만 전송**됨.

## 동작 방식

- `Domain`을 **메인 도메인**으로 지정하면, 하위 서브도메인에서도 동일한 쿠키 사용 가능.

## 장점 및 주의점

- **장점**: 서브도메인 간 **인증 상태 공유** 가능.
- **주의점**: 범위가 넓어지면 **보안 위험** 증가 → 필요한 범위로만 설정.

---

# 쿠키의 Path 디렉티브

## 개념

- **Path 디렉티브**는 쿠키가 **어떤 URL 경로에서 전송될 수 있는지** 지정함.
- 기본값은 `/` → 해당 도메인의 **모든 경로**에 전송됨.

## 동작 방식

- `Path`를 지정하면 그 **경로와 하위 경로**에서만 쿠키 전송.
- 요청 URL이 `Path` 조건을 만족해야 쿠키 포함.

## 장점 및 주의점

- **장점**: 전송 범위 최소화로 **보안성·성능** 향상.
- **주의점**: 너무 세분화하면 관리 복잡.

---

# 세션 쿠키 vs 영속 쿠키

## 1. 세션 쿠키 (Session Cookie)

- **개념**: 브라우저 종료 시 **자동 삭제**되는 쿠키.
- **특징**: 일시적, `Max-Age/Expires` 필요 없음.
- **사용 사례**: 일반 로그인 세션, 임시 상태 관리.

## 2. 영속 쿠키 (Persistent Cookie)

- **개념**: 지정한 만료시간까지 **브라우저에 유지**되는 쿠키.
- **특징**: `Max-Age` 또는 `Expires`로 수명 설정 가능.
- **사용 사례**: 로그인 유지, 장바구니, 사용자 설정.

➡️ 큰 차이: **브라우저 종료 후에도 유지되는가 여부**.

---

# 쿠키의 보안 속성이 방어하는 공격

## 1. HttpOnly

- **개념**: JS에서 쿠키 접근 차단.
- **효과**: XSS 공격자가 스크립트로 세션 쿠키를 훔치는 것 방지.

## 2. Secure

- **개념**: HTTPS 연결에서만 쿠키 전송.
- **효과**: MITM(중간자 공격) 방지, 공용 Wi‑Fi에서 안전.

## 3. SameSite

- **개념**: CSRF 방지를 위해 쿠키 전송 범위 제한.
- **동작**:
  - `Strict`: 같은 사이트 요청에서만 전송.
  - `Lax`: 대부분 안전(최상위 네비게이션의 GET 허용).
  - `None; Secure`: 모든 크로스 사이트 요청에서 전송(HTTPS 필요).
- **효과**: 악의적 사이트가 사용자의 인증 쿠키를 악용하는 CSRF 방지.

---

# 쿠키의 한계점

## 1. 용량 제한

- 각 쿠키 **최대 4KB** 정도.
- 브라우저마다 **도메인당 쿠키 개수 제한** 존재.
- 많은 데이터 저장 불가.

## 2. 보안 취약성

- 클라이언트에 저장되어 **조작 가능**.
- 예: `role=user` → 개발자 도구로 `role=admin` 변경 가능.
- 민감 정보 저장에 부적합.

## 3. 네트워크 오버헤드

- 도메인에 속한 모든 요청에 쿠키 자동 전송.
- 이미지/CSS/JS 요청에도 포함될 수 있어 **불필요한 트래픽 증가**.

## 4. 도메인 제약

- 설정된 도메인에서만 접근 가능.
- 보안에는 유리하나 MSA나 SSO 구현에서는 제약 요인.

---

# 쿠키만으로 상태 관리를 해결할 수 없는 이유

- 쿠키의 한계점(용량, 보안, 네트워크, 도메인 제약) 때문에 복잡한 상태 관리에 부적합.

## 1. 브라우저가 쿠키를 직접 삭제할 수 있음

- 사용자가 종료하거나 삭제하면 상태 사라짐.
- 예: 장바구니가 브라우저 종료로 사라짐.

## 2. 상태 동기화 불가능

- 쿠키는 **클라이언트 쪽 저장** → 서버·다른 클라이언트에 실시간 반영 어려움.
- 예: 여러 장치에서 동일 계정 사용 시 즉시 동기화 불가.

## 3. 민감 정보 저장 불가

- 클라이언트 저장이므로 **조작·유출 위험**.
- 로그인 세션이나 권한 정보를 그대로 담으면 취약.

## 4. 상태 데이터 복잡성 한계

- 용량·구조 제한으로 다단계 입력값이나 복합 상태 관리 불가.
- 예: 다단계 회원가입의 입력값, 장바구니+결제옵션+쿠폰 상태 동시 관리 어려움.

---

# XSS (Cross‑Site Scripting) — 크로스 사이트 스크립팅

## 개념

- 공격자가 **악성 스크립트**를 웹 애플리케이션에 주입.
- 주입된 스크립트가 **다른 사용자 브라우저에서 실행**되도록 만듦.
- 결과: 세션 탈취, 쿠키 노출, UI 변조, 피싱 등 발생할 수 있음.

## 취약 동작 흐름

```tsx
<div class="comment">{{ userComment }}</div>
```

```tsx
<script>alert('XSS 취약점!');</script>
```

1. 사용자가 댓글/입력 폼에 `<script>...</script>` 같은 코드 입력.
2. 애플리케이션이 입력을 **검증·정화 없이 저장**.
3. 렌더링 시 입력을 **이스케이프 없이 삽입**.
4. 브라우저가 이를 **JS로 해석·실행** → 방문자에게 악영향.

---

# 방어 전략

## 정화 (Sanitization)

- 위험한 HTML 태그·JS를 제거.
- 라이브러리 예: DOMPurify, sanitize-html.
- 목적: 허용된 마크업만 남기고 스크립트 제거.

## 이스케이프 (Escaping)

- 특수문자를 **HTML 엔티티**로 변환하여 해석 방지.
- 변환 순서 중요: **`&`를 먼저`** 처리한 뒤 `<`, `>`, `"` , `'` 순으로 변환해야 함.
  - 예: `&` → `&amp;`, `<` → `&lt;`, `>` → `&gt;`, `"` → `&quot;`, `'` → `&#39;`

## 입력 검증 (Validation)

- 허용된 입력 형식만 받기.
- 길이, 타입, 허용 문자 범위 등 서버·클라이언트에서 검증.

## 콘텐츠 보안 정책 (CSP)

- 브라우저에 허용된 스크립트 출처만 실행하도록 지시.
- 인라인 스크립트·의심스러운 외부 스크립트 차단 가능.

## 출처 분리 · 최소 권한

- 사용자 입력은 가능한 한 **HTML이 아닌 텍스트**로 처리.
- 템플릿 엔진의 자동 이스케이프 사용.

---

# 세션 하이재킹

## 개념

- 진행 중인 인증 상태(세션 ID, 인증 토큰 등)를 공격자가 탈취해 **해당 사용자로 가장하여 서비스에 접근**하는 공격임.
- 예: `Set-Cookie: sid=abcd1234`가 `HttpOnly`/`Secure` 없이 평문 HTTP로 전송되면 네트워크에서 탈취되어 동일 세션으로 접근 가능함.

# 🛡️ XSS 차단 방법

## 1 XSS 취약점 제거 (근본 차단)

- **출력 인코딩(Encoding)**: HTML/속성/JS/URL 문맥별로 인코딩함 (`<`→`&lt;` 등).
- **정화(Sanitization)**: 허용 HTML만 남기고 위험 요소 제거 (예: DOMPurify, sanitize-html).
- **안전한 렌더링**: `innerHTML` 대신 `textContent` 사용. 템플릿 엔진 자동 이스케이프 활용.
- **CSP 적용**: 인라인 스크립트 차단 및 신뢰 출처만 허용.

## 2 HttpOnly 쿠키 플래그 (보조 방어)

- `Set-Cookie: sid=...; HttpOnly; Secure; SameSite=Lax` 처럼 설정.
- JS 접근 차단으로 쿠키 탈취 위험 감소.
- 단점: XSS 자체를 완전히 막지는 못함. `Secure(HTTPS)`는 필수.

---

# 쿠키 옵션 정리

## 1. Max-Age (만료 시간)

- 초 단위 수명 지정. 없으면 세션 쿠키(브라우저 종료 시 삭제).
- 예: `Set-Cookie: sid=abcd1234; Max-Age=3600` → 1시간 후 만료.

## 2. Domain (전송 도메인)

- 쿠키를 전송할 도메인(및 하위 도메인) 지정.
- 예: `Set-Cookie: sid=abcd1234; Domain=example.com` → `shop.example.com` 등에서 전송됨.

## 3. Path (전송 경로)

- 쿠키 전송을 특정 경로와 하위 경로로 제한.
- 예: `Set-Cookie: sid=abcd1234; Path=/private` → `/private` 및 하위에서만 전송.

## 4. Secure (HTTPS 전송만)

- HTTPS 연결에서만 쿠키 전송. 네트워크 도청 방지용.
- 예: `Set-Cookie: sid=abcd1234; Secure`

## 5. HttpOnly (JS 접근 차단)

- `document.cookie`로 접근 불가. XSS로 인한 쿠키 탈취 방지.
- 예: `Set-Cookie: sid=abcd1234; HttpOnly`

---

# CSRF 방어 전략 요약

## SameSite 쿠키

- **개념**: 브라우저가 쿠키를 크로스사이트 요청에 전송할지 제어함.
- **옵션**
  - `SameSite=Strict` : 같은 사이트 내에서만 쿠키 전송. 모든 크로스사이트 요청 차단.
  - `SameSite=Lax` : 대부분의 크로스사이트 요청 차단. 최상위 네비게이션(GET 링크 클릭 등)은 허용(사용자 편의 유지).
  - `SameSite=None; Secure` : 모든 크로스사이트 요청에서 쿠키 전송 허용(제3자 쿠키 시나리오). `None` 사용 시 `Secure` 필수.
- **장점**: 설정만으로 많은 CSRF 사례 자동 차단, 서버 변경 최소화.
- **한계**: 제3자 쿠키/SSO 필요 시 보호 사라짐. 일부 브라우저 호환성 이슈 존재.

---

## CSRF 토큰

- **개념**: 서버가 발급한 난수 토큰을 클라이언트가 요청에 포함시켜 서버가 검증함.
- **동작**: 서버에 저장된 토큰과 요청 토큰을 비교해 일치하면 처리, 아니면 거부.
- **장점**
  - 브라우저 전반에 걸쳐 신뢰성 높음(오래된 브라우저 포함).
  - `SameSite`와 병용 시 이중 방어 가능.
  - 액션/폼별로 세밀한 제어 가능.
- **단점**
  - 구현 및 검증 로직 필요(폼·AJAX마다 토큰 포함).
  - 토큰 저장/만료 관리 오버헤드.
  - XSS가 있으면 토큰 유출 가능하므로 XSS 방어 병행 필수.

---

## CAPTCHA

- **개념**: 사람과 봇을 구분하는 테스트. 자동화 공격(스팸, 봇 가입, 무차별 로그인 등) 방어 목적.
- **유형 예시**
  - 텍스트 왜곡 입력, 이미지 선택, 체크박스형(behavior 기반) 등.
- **장점**: 자동화된 봇 공격을 효과적으로 차단 가능.
- **단점**: 사용자 경험 저하. 최신 OCR/봇 기술에는 완전하지 않음.

# 요약 — 실전 권장 조합

- **기본**: `SameSite=Lax` + `Secure` + `HttpOnly` 쿠키 적용.
- **중요한 상태 변경(POST/PUT/DELETE)**: CSRF 토큰 적용으로 강력 검증.
- **봇/자동화 방지**: 의심 트래픽에 CAPTCHA 적용.
- **주의**: XSS가 존재하면 CSRF 토큰·쿠키 보호 모두 무력화될 수 있으니 **XSS 방어 선행**.

---

# 인증·쿠키·토큰 요약

## 쿠키가 브라우저에 자동 포함되는 조건

1. **오리진(Origin) 일치**
   - 프로토콜·도메인·포트가 모두 일치해야 자동 전송됨.
2. **Path 조건 충족**
   - 요청 경로가 쿠키의 `Path`와 같거나 하위일 것.
3. **보안 속성 만족**
   - `Secure` → HTTPS에서만 전송.
   - `HttpOnly` → JS 접근 차단(전송에는 영향 없음).
   - `SameSite` → 크로스 사이트 전송 제어(`Strict`, `Lax`, `None`).
4. **CORS 상황**
   - 다른 오리진이면 기본 비포함. `credentials: 'include'` / `withCredentials:true` 필요.

---

## 크로스 도메인(크로스 오리진) 쿠키 전송 설정

- **서버**
  - `Access-Control-Allow-Credentials: true` 필수.
  - `Access-Control-Allow-Origin`에 와일드카드 불가. 요청 도메인 명시 필요.
  - 쿠키 옵션: `Secure`, `SameSite=None`, `HttpOnly` 권장.
- **클라이언트**
  - Fetch: `credentials: 'include'`.
  - Axios: `withCredentials: true`.
- 결과: 서버·클라이언트 모두 설정해야 쿠키가 교차 전송됨.

---

## 쿠키 기반 인증에서 CSRF 발생 원리

1. 브라우저가 동일 오리진 요청에 **쿠키를 자동 포함**함.
2. 공격자가 피해자를 유도해 **다른 사이트에서 요청을 발생**시킴.
3. 브라우저는 자동으로 대상 도메인 쿠키를 붙여 보냄.
4. 서버는 쿠키를 보고 요청을 **정상 사용자 요청**으로 처리.  
   → 사용자의 의사와 무관한 상태 변경이 발생함.

---

## 헤더 방식 인증(예: Authorization 헤더)의 장점

1. **CSRF 방지**: 브라우저가 자동으로 헤더를 붙이지 않으므로 위조 불가.
2. **선택적 전송**: 필요한 요청에만 토큰 포함 → 네트워크 효율성.
3. **CORS 간소화**: 쿠키·credentials 제약에서 자유로움(단, 보안 설계 필요).
4. **애플리케이션 제어성**: 토큰 발급·갱신·전송 로직을 앱에서 완전 제어 가능.

---

## 클라이언트 저장소 전략 비교

- **LocalStorage**
  - 장점: 영구 저장, 사용 편의성.
  - 단점: XSS에 취약(JS로 토큰 탈취 가능).
- **SessionStorage**
  - 장점: 탭 단위 격리, 탭 종료 시 삭제.
  - 단점: XSS 취약, 탭 간 상태 공유 불가.
- **메모리 저장 (JS 변수/상태)**
  - 장점: 새로고침 전까지만 유지 → XSS 상대적으로 안전.
  - 단점: 새로고침/종료 시 소실 → 영속성 부족.

---

## 권장 인증 전략 (환경별)

- **SPA (React/Vue 등)**
  - 추천: `HttpOnly + Secure` 쿠키 기반 인증.
  - 이유: XSS로부터 안전, 새로고침·네비게이션에서 상태 유지 쉬움.
- **모바일 앱 (iOS/Android, React Native 등)**
  - 추천: 헤더 기반 토큰 + 플랫폼 안전 저장소(예: Keychain, Keystore).
  - 이유: 브라우저 쿠키 모델과 다르며, 네이티브 저장소가 안전.
- **SSR (Next.js, Nuxt 등 서버 렌더링)**
  - 추천: 서버에서 쿠키 파싱 및 인증 처리. `HttpOnly` 쿠키 사용.
  - 이유: 초기 렌더링 시 인증 정보 사용 용이, 서버·클라이언트 일관성 확보.

---
