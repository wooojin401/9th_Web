- 세션 방식과 토큰 방식의 가장 큰 차이는 무엇인가요? 🍠
    
    세션 방식과 토큰 방식의 가장 큰 차이점은 **사용자 인증 정보의 저장 위치**와 그에 따른 **서버 상태 유지 여부**입니다.
    
    세션 방식은 **서버가 클라이언트의 상태를 유지**하는 전통적인 인증 방식입니다.
    
    **작동 원리**
    
    1. **로그인** : 클라이언트가 로그인 요청을 하면, 서버는 사용자 정보를 확인하고 고유한 세션 ID 를 생성합니다.
    2. **서버 저장** : 서버는 이 세션 ID 와 사용자 정보를 서버의 세션 저장소 (메모리, 파일, 데이터 베이스 등) 에 저장합니다.
    3. **클라이언트 전달** : 서버는 세션 ID 를 클라이언트에게 쿠키 형태로 전달합니다.
    4. **요청 처리** : 이후 클라이언트가 요청할 때마다 쿠키를 통해 세션 ID 를 전송하고, 서버는 이를 확인하여 해당 사용자가 누구인지 파악하고 인증합니다.
    
    **확장성 및 문제점** 
    
    - **수평 확장 어려움** : 서버를 여러 대로 늘릴 때 (로드 밸런싱) 문제가 발생합니다. 특정 서버에 저장된 세션 정보가 다른 서버에는 없기 때문에, 모든 서버가 동일한 세션 저장소를 공유하도록 설정해야 하는 추가적인 작업 복잡성이 생깁니다.
    - **서버 부하** : 사용자가 많아질수록 서버는 더 많은 세션 정보를 저장하고 관리하여야 하므로, 세션 저장소에 대한 부하가 증가합니다.
    
    토큰 방식은 **서버가 클라이언트의 상태를 별도로 유지하지 않는 무상태 인증** 방식입니다. JWT 가 가장 흔하게 사용됩니다.
    
    **작동 원리**
    
    1. **로그인** : 클라이언트가 로그인 요청을 하면 서버는 사용자 정보를 확인하고 사용자 정보가 담긴 토큰을 생성합니다.
    2. **서버 저장** : 서버는 사용자 정보를 별도로 저장하지 않습니다. ⇒ 무상태
    3. **클라이언트 전달** :  서버는 생성된 토큰을 클라이언트에게 전달하고 클라이언트는 이 토큰을 로컬 저장소 (LocalStorage) / 쿠키에 저장합니다.
    4. **요청 처리** : 이후 클라이언트가 요청할 때마다 토큰을 HTTP 헤더 (Authorization 헤더) 에 담아 전송합니다. 서버는 토큰의 유효성을 확인하여 사용자 인증을 완료합니다.
    
    **확장성 및 이점**
    
    - **수평 확장 용이:** 서버 간에 세션 정보를 공유할 필요가 없습니다. 각 서버는 토큰의 유효성만 검증하면 되므로, 서버를 자유롭게 늘릴 수 있어 확장성이 뛰어납니다.
    - **다중 도메인/크로스 플랫폼:** 토큰은 HTTP 헤더를 통해 전송되기 때문에 웹(SPA), 모바일 앱 등 다양한 클라이언트와 도메인에서 쉽게 인증을 처리할 수 있습니다.
    
    **세션 VS 토큰 방식의 차이점**
    
    | 구분 | 세션 기반 인증 | 토큰 기반 인증 |
    | --- | --- | --- |
    | 토큰 만료 처리 | 서버에서 세션 정보 삭제 | 토큰 만료 전 강제 탈취 시. 서버에서 즉시 무효화 어려움 |
    | CSRF 방어 | 쿠키 사용 → 취약 | 토큰을 HTTP 헤더에 담음 → 유리 |
    | 오버헤드 | 요청 시마다 저장소 조회 → 오버헤드 발생 | 토큰에 정보가 많으면 네트워크 전송량이 커짐 → 오버헤드 발생 |
    | 정보 포함 여부 | 세션 ID 만 전송 | 토큰 자체에 사용자 정보 포함 |
- 세션을 분산 환경에서 관리할 때 사용할 수 있는 세 가지 전략(Sticky Session, Session Replication, Centralized Session Store)의 특징을 정리해주세요. 🍠
    1. **Sticky Session (세션 고정)**
        
        Sticky Session 방식은 특정 사용자의 모든 요청을 항상 **동일한 웹 서버**로만 전달되도록 하는 로드 밸런서 (Load Balancer) 가 설정하는 전략입니다.
        
        - **원리** : 로드 밸런서가 사용자로부터 받은 쿠키 또는 세션 ID 를 기반으로 이 사용자를 이전에 처리했던 서버로 고정하여 라우팅합니다.
        - **장점** : 구현이 비교적 간단하고, 서버 내부에서 세션 데이터를 저장하므로 추가적인 네트워크 트래픽이나 **저장소 부하가 없습니다. 성능이 빠릅니다.**
        - **단점** : **확장성과 안전성이 낮습니다.** 만약 특정 서버가 다운되면, 그 서버에 세션이 고정되어 있던 사용자들은 세션을 잃고 강제로 로그아웃 됩니다. 서버 간 부하 분산이 고르지 않을 수 있습니다.
        - **사용** : 세션 복잡성이 낮고 서버 다운 시 재접속을 하용하는 소규모 환경에 적합
    
    1. **Session Replication (세션 복제)**
        
        Session Replication 방식은 세션 정보가 생성되거나 변경될 때마다 클러스터 내의 모든 웹 서버로 해당 세션 데이터를 복사하고 동기화하는 전략입니다.
        
        - 원리 : 세션 정보가 모든 서버에 복제되므로, 로드 밸런서가 요청을 어느 서버로 보내든 사용자 세션을 찾을 수 있습니다.
        - 장점 : **안정성이 가장 뛰어납니다.** 특정 서버가 다운되어도 다른 서버에 동일한 세션 정보가 남아 있어 서비스 연속성이 보장됩니다.
        - 단점 : **네트워크 부하가 매우 큽니다.** 세션이 변경될 때마다 모든 서버로 데이터를 복제해야 하므로, 사용자 수나 세션 크기가 크면 네트워크와 서버 메모리 자원의 비효율이 발생합니다. **실시간 동기화 오버헤드**가 큽니다.
        - 사용 : 안정성과 높은 가용성이 최우선이며, 서버 수가 적고 세션 데이터의 크기가 작은 환경에 적합합니다.
    
    1. **Centralized Session Store (중앙 집중식 세션 저장소)**
        
        Centralized Session Store 방식은 모든 웹 서버가 별도의 중앙 집중식 저장소에 세션 정보를 저장하고 조회하는 전략입니다.
        
        - 원리 : 웹 서버는 세션 ID 만 관리하고 실제 세션 데이터의 읽기 또는 쓰기는 외부의 전용 세션 저장소를 통해 처리합니다. **서버는 무상태가 됩니다.**
        - 장점 : **확장성이 가장 뛰어납니다.** 웹 서버를 자유롭게 늘릴 수 있고 서버가 다운되어도 세션 데이터는 중앙 저장소에 안전하게 남아 있습니다.
        - 단점 : 세션 읽기 또는 쓰기 시 **별도의 네트워크 요청이 중앙 저장소로 발생**하므로, Sticky Session 방식 대비 **약간의 지연이 발생**합니다. 중앙 저장소 자체의 안전성 및 용량 관리가 필요합니다.
        - 사용 : 대규모 트래픽 환경, 빈번한 서버의 확장 또는 푹소가 필요한 환경, 클라우드 기반 환경
- JWT(Json Web Token)의 장점과 단점을 각각 설명해주세요. 🍠
    
    **JWT 의 장점**
    
    1. **무상태성 및 확장성 (Stateless & Scalability)**
        
        JWT 의 가장 큰 장점은 무상태성입니다.
        
        - **서버 부담 감소** : 서버가 사용자 세션 정보를 별도로 저장하거나 관리할 필요가 없습니다.
            
            ⇒ 서버의 메모리나 데이터베이스 자원을 절약합니다.
            
        - **수평 확장 용이** : 인증 정보를 토큰 자체에 담아 서버 간 공유할 필요가 없으므로 웹 서버를 늘리는대로 수평 확장이 간편합니다.
            
            ⇒ 대규모 트래픽을 처리하는 분산 환경에 유리
            
    2. **다양한 클라이언트 환경 지원** 
        
        토큰은 HTTP 헤더를 통해 전송되기 때문에 다양한 환경에서 쉽게 사용 가능
        
        - **크로스 플랫폼 / 도메인** : 웹 애플리케이션, 모바일 앱, 데스크탑 앱 등 어떤 클라이언트 환경에서도 동일한 인증 메커니즘을 사용할 수 있습니다.
        - **CORS** : 쿠키를 사용하지 않기 때문에 서버로 다른 도메인 간의 인증 요청 시 빌생하는 CORS 문제를 비교적 쉽게 해결할 수 있습니다.
    
    1. **정보 포함**
        
        JWT 는 정보를 담고 있는 자체 봉인 형식입니다.
        
        - 불필요한 DB 조회 감소 : 토큰의 페이로드에 사용자 ID, 권한, 만료 시간 등의 기본적인 정보를 담을 수 있습니다.
            
            ⇒ 서버는 이 정보를 사용하기 위해 DB 를 별도로 조회할 필요가 없어 성능이 향상됩니다.
            
        - **데이터 무결성** : 토큰의 마지막 부분인 서명을 통해 토큰의 내용이 위변조되지 않았는지 검증할 수 있습니다.
    2. **RESTful API 설계 용이**
        
        무상태 원칙을 따르므로 RESTful 아키텍처 원칙에 완벽하게 부합하는 API 설계 용이
        
    
    **JWT 단점**
    
    1. **토큰 크기 및 전송 오버헤드 (Token Size & Overhead)**
        - **네트워크 부하** : JWT 는 사용자 정보를 담고 있어, 세션 ID 만 담는 세션 방식의 쿠키보다 토큰 크기가 더 큽니다. 이 토큰이 모든 HTTP 요청마다 헤더에 포함되어 전송되기 때문에 페이로드에 많은 정보를 담을수록 네트워크 낭비가 커집니다.
        - **정보 노출 위험** : 페이로드가 Base64 로 인코딩되기 때문에, 토큰 탈취 시 암호화되지 않은 정보가 외부에 그대로 노출됩니다. 따라서 비밀번호나 중요 정보를 페이로드에 저장하면 안됩니다.
        
    2. **보안 취약성**
        - **강제 만료 및 회수 어려움:** 토큰은 한 번 발급되면 만료 시간이 지나기 전까지는 유효합니다. 만약 해커에게 토큰이 탈취당했을 경우, 서버는 이 토큰의 유효 기간을 강제로 취소하기가 어렵습니다.
            
            ⇒ 이를 해결하기 위해 토큰을 블랙리스트에 저장하고 요텅 시마다 확인할 수 있으나 이는 다시 상태 관리로 돌아가는 것이기 때문에 JWT 의 무상태 이점을 상실합니다.
            
        - **저장 방식 문제 (XSS 공격)** : JWT 를 클라이언트의 로컬 저장소에 저장하는 경우가 많으나 이 경우 XSS 공격에 매우 취약합니다. 따라서 HTTP-only 쿠키에 저장하는 것이 더 권장되고 있습니다.
        
    3. **암호화 제한**
        - **서명만 지원** : JWT 의 표준은 데이터가 변조되지 않았음을 보장하는 서명을 필수로 요구합니다. 페이로드의 내용 자체를 숨기는 암호화는 기본으로 제공되지 않습니다.
            
            만약 페이로드의 정보 자체를 보호하고 싶다면, JWT 외에 JWE 와 같은 표준을 추가 적용하여야 합니다.
            
- JWT의 즉시 무효화 문제가 생기는 이유와 이를 해결하기 위한 방법은 무엇인가요? 🍠
    
    JWT 의 즉시 무효화 문제는 무상태성 때문에 발생합니다. 
    
    1. JWT 인증 과정 
        - 발급 : 사용자가 로그인하면, 서버는 사용자의 정보와 만료 시간을 담아 비밀 키로 서명한 JWT 를 생성하여 클라이언트에게 전달합니다.
        - 인증 : 클라이언트는 이후 API 를 요청할 때마다 이 JWT 를 함께 보냅니다.
        - 검증 : 서버는 JWT 를 받으면 데이터베이스를 조회하지 않고 자신이 가진 비밀 키로 서명이 유효한지 검증합니다. 서명이 유효하고 만료되지 않았다면 요청을 신뢰하고 처리합니다.
    
    1. 핵심 문제
        
        서버는 한 번 발급한 JWT 에 대해 토큰의 사용 여부를 기억할 저장 장소가 없습니다. 한 번 쓰고 버리는 일회용 입장권이 됩니다. 즉 다음과 같은 문제가 발생합니다.
        
        - 로그아웃 : 사용자가 로그아웃 해도 만료 시간이 남은 JWT 는 여전히 유효합니다. 만약 이 토큰이 탈취되면 공격자는 만료 시간까지 해당 사용자인 척 위장할 수 있습니다.
        - 비밀번호 변경 : 사용자가 비밀번호를 바꿔도 이전에 발급된 JWT 는 여전히 유효합니다.
        - 관리자에 의한 계정 비활성화 : 관리자가 특정 사용자를 강제로 로그아웃 시키거나 차단해도 그 사용자가 가지고 있는 JWT 는 만료 시간까지 계속 사용될 수 있습니다.
    
    해결 방안
    
    1. Access Token 의 유효 시간을 짧게 설정 + Refresh Token 사용
        
        가장 널리 사용되는 권장 방법입니다. 두 종류의 토큰을 사용하여 문제를 해결합니다.
        
        - Access Token : 수명이 매우 짧은 토큰으로, 실제 API 요청에 사용합니다. 탈취되더라도 피해를 최소화할 수 있습니다.
        - Refresh Token : 수명이 긴 토큰으로 Access Token 이 만료되었을 때 새로운 Access Token 을 발급 받는 용도로만 사용됩니다. 이 토큰은 서버의 데이터베이스에 저장하여 관리합니다.
        
        동작 방식 
        
        1. 사용자가 로그아웃 하면, 서버는 데이터베이스에 저장된 Refresh Token 을 즉시 삭제합니다.
        2. 공격자가 탈취한 Access Token 을 사용하더라도 짧은 시간 내에 만료됩니다.
        3. 만료된 Access Token 으로 새로운 Access Token 을 발급 받으려고 해도 서버에 해당 Refresh Token 이 이미 삭제 되었기 때문에 발급 거부
    
    | 장점 | 단점 |
    | --- | --- |
    | 강력한 보안 : Access Roken 수명 짧음 → 탈취 시 피해 적음 | 구현이 다른 방식에 비해 복잡 |
    | 매 요청마다 DB 조회 X → JWT 장점 유지 | 즉각적인 대응 : Refresh Token 무효화 시 새로운 Access Token 발급 불가  |
    
    1. 블랙리스트 구축
        
        무효화 할 JWT 를 명단에 올려 관리하는 방식입니다. 주로 Redis 와 같은 빠른 In-Memory DB 를 사용합니다.
        
        동작 방식
        
        1. 사용자가 로그아웃 시 해당 Access Token 의 고유 식별자나 토큰 자체를 Redis 같은 블랙리스트 저장소에 저장
        2. 이때 블랙리스트에 저장하는 토큰의 만료 시간은 기존 Access Token 의 만료 시간과 동일하게 설정하여 불필요한 데이터가 쌓이지 않도록 합니다.
        3. 서버는 API 요청을 받을 때마다 토큰이 유효한 지 검증한 후 추가적으로 블랙리스트에 해당 토큰이 있는지 확인합니다.
        4. 블랙리스트에 존재한다면 유효한 토큰이더라도 인증을 거부합니다.
        
        | 장점 | 단점 |
        | --- | --- |
        | 즉각 무효화 : 어떤 토큰이든 즉시 사용을 막음 | 매 API 요청마다 블랙리스트를 조회해야 하므로 성능 저하 발생 |
        | 간단한 로직 : 구현 로직이 비교적 단순 | 블랙리스트 관리를 위한 별도의 저장소 필요 |
        
    2. 토큰에 버전 / 개정 번호 부여
        
        사용자 정보에 버전이나 개정 번호를 두고, JWT 를 발급할 때 이 정보를 포함시키는 방식
        
        동작 방식
        
        1. User DB 테이블에 `token_version` 과 같은 column 을 추가하고 초기값을 1 로 설정합니다.
        2. JWT 의 페이로드에 `version : 1` 을 포함하여 발급합니다.
        3. 서버는 API 요청이 오면 JWT 의 서명과 만료 시간을 검증한 뒤 토큰에 담긴 version 과 DB 에 저장된 사용자의 `token_version` 을 비교합니다.
        4. 사용자가 비밀번호를 변경하거나 강제 로그아웃이 필요한 경우 DB 의 `token_version` 값을 1 증가시킵니다.
        5. 구버전 (`version : 1`) 이 담긴 모든 JWT 는 DB 의 버전과 일치하지 않으므로 자동으로 인증이 실패됩니다.
        
        | 장점 | 단점 |
        | --- | --- |
        | 간단 무효화 : DB 값 한 번만 바꾸면 모든 토큰 무효화 | 매 API 요청마다 DB 조회가 필요하여 JWT 의 무상태성 일부 상쇄 |
        | 별도 저장소 불필요 | 사용자 한 명이 모든 기기에서 동시 로그아웃 |
    
- 세션과 토큰을 결합한 하이브리드 방식(JWT + 저장소 메타데이터)의 동작 원리를 간단히 설명해주세요. 🍠
    
    이 방식의 핵심은 토큰의 무상태성에 대한 장점을 누리면서 필요할 때는 세션처럼 서버에서 통제권을 갖는 것입니다.
    
    하이브리드 방식은 아래 두 가지를 충족합니다.
    
    - **Access Token (단기 토큰):** 기존 JWT처럼 Stateless하게 사용하여 **빠른 API 인증**을 담당합니다.
    - **Refresh Token (장기 토큰):** 서버의 **저장소에 메타데이터를 저장**하여 세션처럼 관리합니다. 이를 통해 **즉시 무효화, 동시 접속 제어** 등 통제권을 확보합니다.
    
    주요 구성 요소
    
    1. 클라이언트
        - Access Token : 수명이 매우 짧고, 메모리에 저장, 실제 API 요청 헤더에 담겨 전송
        - Refresh Token : 수명이 길고 HttpOnly 쿠키에 저장되어 보관, 재발급 용도로만 사용
    2. 서버
        - JWT 비밀 키 : 토큰의 서명을 생성하고 검증하기 위한 키
        - 토큰 메타데이터 저장소 : Refresh Token 의 상태를 관리하는 저장소
            - 사용자 ID
            - 토큰 고유 ID
            - 발급 시 사용자의 IP 주소
            - 발급 시 User-Agent
            - 토큰 만료 시간
            - 마지막 사용 시간
    
    상세 동작 원리
    
    1. **최초 로그인**
        
        사용자가 아이디 비밀번호로 로그인 요청
        
        서버는 사용자 인증에 성공 시 AT, RT 생성
        
        서버는 생성된 RT 의 메타데이터를 저장소에 기록
        
        서버는 클라이언트에게 (AT 는 JSON 응답 본문에, RT 는 HttpOnly 쿠키에) 담아 전달
        
        클라이언트는 AT 를 메모리에 저장
        
    2. **API 요청**
        
        클라이언트는 API 요청 시 Authorization 헤더에 AT 를 담아 보냄
        
        서버는 저장소 조회 X, JWT 의 서명과 만료 시간 검증
        
        인증이 완료되면 API 응답 반환 (토큰의 무상태성 활용)
        
    3. **Access Token 만료 및 재발급**
        
        클라이언트는 API 요청 후 `401 Unuthorization` 받음
        
        클라이언트는 토큰 재발급 API 호출, 이때 브라우저는 자동으로 HttpOnly 에 담긴 RT 를 함께 전송
        
        서버는 전달 받은 RT 에 대해 아래 순차 검증
        
        - 1차 검증 : JWT 서명 및 만료 시간 검증
        - 2차 검증 : 메타데이터 저장소를 조회하여 해당 RT 정보가 존재하는지, 강제 로그아웃 처리되진 않았는지 확인
        
        모든 검증 통과 시 서버는 새로운 토큰을 생성하여 클라이언트 전달, 이로 다시 API 요청 시도
        
    4. **로그아웃 및 강제 무효화**
        
        사용자 로그아웃 요청
        
        서버는 요청에 포함된 RT 확인 후 메타데이터 저장소에서 해당 토큰 삭제
        
        해당 RT 가 서명 상 유효하더라도, 2차 검증에서 저장소에 기록이 더이상 없으므로 AT 발급 불가 (세션처럼 즉시 무효화 완료)
        
        모든 기기에서 로그아웃 (`user_id` 에 연결된 모든 RT 메타데이터 삭제로 구현)
        
    
    | 장점 | 단점 |
    | --- | --- |
    | 즉시 무료화 가능 | 구현 복잡도 증가 |
    | 높은 보안성 | 부분적인 무상태성 |
    | 세션 통제 기능 | 저장소 의존성 |
    | 성능 효율 |  |

- HTTP는 왜 무상태(Stateless)로 설계되었나요? 🍠
    
    웹이 처음 만들어질 때에는 단순한 문서 전송이 주 목적이였고, 수백만 명의 사용자가 동시에 접속하는 대규모 서비스는 상상하기 어려웠기 때문에 확장성과 단순성을 확보하기 위해 무상태성으로 설계되었습니다.
    
- HTTP의 무상태성이 주는 장점과 단점을 각각 정리해주세요. 🍠
    
    **HTTP의 무상태성  장점**
    
    1. **확장성** : 서버를 수평적으로 확장하기 쉬워, 어떤 서버든 요청을 처리할 수 있으니 로드 밸런서가 트래픽만 분산하면 됩니다.
    2. **신뢰성** : 서버가 하나 죽어도 다른 서버가 즉시 대체 가능, 유지할 상태가 없기 때문에 복구도 간단
    3. **단순성** : 서버가 클라이언트별 상태를 관리하지 않아도 되어 구현 단순
    
    **HTTP의 무상태성  단점**
    
    현대 웹 애플리케이션은 단순한 문서 조회가 아닌 복잡한 상호작용을 요구하는 연속성 있는 작업 필요, 즉 상태 유지의 필요겅과 HTTP 의 무상태성 사이 모순 발생
    
- 쿠키의 Domain 디렉티브에 대해 정리해주세요. 🍠
    
    해당 쿠키가 전송되어야 하는 호스트를 지정하며, 쿠키가 적용될 도메인을 명시하여 쿠키의 범위를 조절합니다.
    
    **Domain 디렉티브의 기능**
    
    - **쿠키 적용 범위 지정 :** example.com 으로 설정하면 www.example.com, blog.example.com 등 example.com 의 **모든 서브도메인에 쿠키가 전송**됩니다.
    - **동일 도메인 쿠키 전송 :** 브라우저가 해당 Domain 에 해당하는 서버로 요청을 보낼 때, 설정된 쿠키를 함께 전송하게 됩니다.
    
    **Domain 디렉티브의 주의사항**
    
    - **보안** : Domain 디렉티브를 설정하지 않으면 쿠키는 설정한 도메인 자체에만 유효하여 서브 도메인에 쿠키가 전송되는 것을 방지하거나 허용하는 데 사용합니다.
    - **상대 경로** : 현재 브라우저에서 제공하는 쿠키는 특정 도메인에 국한되며, 브라우전 간에 쿠키가 공유되지 않습니다.
- 쿠키의 Path 디렉티브에 대해 정리해주세요. 🍠
    
    쿠키의 유효 범위를 지정된 URL 경로로 제한합니다. Path 속성을 설정하면 브라우저는 지정된 경로 밒 해당 하위 경로에서만 쿠키를 전송하여 쿠키의 스코프를 특정 디렉토리에만 한정할 수 있습니다.
    
    **Path 디렉티브의 역할**
    
    - **스코프 정의** : 쿠키가 어떤 URL에서 활성화될 수 있는지를 결정합니다.
    - **경로 기반 제어** : 특정 디렉토리에서만 쿠키가 사용되도록 제어할 수 있습니다.
    
- 세션 쿠키와, 영속 쿠키의 차이점을 정리해주세요. 🍠
    
    세션 쿠키는 브라우저를 닫으면 사라지나, 영속 쿠키는 브라우저 종료 후에도 디스크에 저장되어 남아있다는 점입니다. 
    
    세션 쿠키는 메모리에만 저장되어 브라우저 종료 시 자동 삭제되는 반면, 영속 쿠키는 만료 날짜가 지정되어 해당 날짜가 되면 삭제됩니다.
    
    **세션 쿠키 (Session Cookie)**
    
    - **저장 위치** : 브라우저 메모리에 저장됩니다.
    - **유효 기간** : 만료 날짜가 없으며, 브라우저가 닫히면 즉시 삭제됩니다.
    - **주요 용도** : 사용자가 웹사이트를 탐색하는 동안의 상태를 유지하는 데 사용됩니다.
    
    **영속 쿠키 (Persistent Cookie)**
    
    - **저장 위치** : 사용자의 디스크 (하드디스크) 에 저장됩니다.
    - **유효 기간** : 만료 날짜 또는 유효 시간이 지정되어 있으며, 지정된 시간이 지나면 자동으로 삭제됩니다.
    - **주요 용도** : 사용자 로그인 정보 유지, 장바구니 기능, 팝업 창 등 사용자의 정보를 오랫동안 기억할 때 사용됩니다.
    
    | 구분 | 세션 쿠키 | 영속 쿠키 |
    | --- | --- | --- |
    | 저장 위치 | 브라우저 메모리 | 하드 디스크 |
    | 유효 기간 | 브라우저 종료 시 삭제 | 만료 날짜 지정, 해당 날짜 이후 삭제 |
    | 목적 | 현재 세션 동안의 사용자 상태 유지 | 장기적인 사용자 정보 기억 |
    
- 쿠키의 보안 속성(HttpOnly, Secure, SameSite)은 각각 어떤 공격을 방어하나요? 🍠
    - **HttpOnly** : JS 에서 쿠키에 접근하는 것을 막아주어 XSS 공격으로 쿠키를 탈취하는 것을 방지할 수 있습니다.
    - **Secure** : HTTPS 연결에서만 쿠키를 전송하도록 제한합니다. 이는 중간자 공격을 방지하여 공공 와이파이 같은 안전하지 않은 네트워크에서도 쿠키가 평문으로 전송되지 않도록 보호합니다.
    - **SameSite** : CSRF 공격을 방어합니다.
        - **Strict** : 같은 사이트에서만 쿠키 전송
        - **Lax** : 안전한 HTTP 메소드 (GET) 로 최상위 네비게이션 시에만 쿠키 전송
        - **None** : 모든 크로스 사이트 요청 허용 (Secure 필수)
- 쿠키의 한계점(용량, 보안, 네트워크, 도메인 제약)을 정리해주세요. 🍠
    1. **용량 제한** : 각 쿠키는 4KB 만 저장할 수 있고 브라우저마다 도메인 당 쿠키 개수도 제한됩니다. 즉 많은 정보를 담기에는 불리합니다.
    2. **보안 취약성** : 쿠키는 클라이언트 측에 저장되므로 사용자가 조작 가능합니다. 예를 들어, 쿠키에 role = user 라는 값을 저장하여도, 개발자 도구로 role = admin 으로 변경 가능합니다.
    3. **네트워크 오버헤드** : 쿠키는 해당 도메인의 모든 요청에 자동으로 포함되어 이미지나 CSS 파일 요청에도 불필요하게 전송됩니다.
    4. **도메인 제약** : 보안상의 이유로 쿠키는 설정된 도메인에서만 접근 가능합니다. 이는 보안을 위한 필수적인 제약이지만, 마이크로서비스 아키텍처처럼 여러 도메인에 걸쳐 서비스가 분산되어 있거나, 파트너 사이트와 인증을 공유해야 하는 SSO 구현 시 제약이 됩니다.
- 쿠키만으로 상태 관리를 해결할 수 없는 이유는 무엇인가요? 🍠
    
    브라우저별, 사용자별 보안 취약점이나 제한된 용량, 전송 방식의 한계점 때문입니다. 쿠키는 공격에 노출되기 쉬워 사용자 정보가 유출되기 쉽고, 너무 많은 데이터를 담기 어려워 특정 브라우저 정택에 따라 전송이 제한될 수 있어 상태 관리에 온전히 사용하기 어렵습니다.

- XSS 공격은 무엇인가요?
    
    **XSS(Cross-Site Scripting)** 는 공격자가 웹 애플리케이션에 악성 스크립트를 삽입해 다른 사용자의 브라우저에서 실행되도록 하는 공격입니다.
    
    - 쿠키 탈취 : 사용자의 세션 쿠키를 훔쳐 계정 탈취
    - 피싱 공격 : 가짜 로그인 폼을 띄워 비밀번호 수집
    - 신원 도용 : 사용자 대신 악의적인 행동 수행
    - 웹사이트 변조 : 페이지 내용을 마음대로 수정
    
    - 추가 정리
        
        웹 해킹 공격 기법 중 하나입니다.
        
        Cross Site Scripting 의 약자이나 이미 CSS 가 Cascading Style Sheets 의 약어로 사용되고 있기 때문에 XSS 라고 칭합니다.
        
        XSS 는 게시판이나 웹 메일 등에 자바 스크립트와 같은 스크립트 코드를 삽입하여 개발자가 고려하지 않은 기능을 작동할 수 있게 하는 공격입니다. 사용자 브라우저에 전달되는 데이터에 악성 스크립트를 포함시켜 브라우저가 실행되면서 해킹됩니다. 대부분의 웹 해킹과는 달리 사용자를 겨냥한 공격이며, 이는 크게 Reflected XSS, Stored XSS, DOM Based XSS 세 가지로 분류됩니다.
        
        SQL Injection 과 함께 웹 취약점 중 가장 기초적인 취약점으로 알려져 있으며, 공격 패턴이 다양하고 변화도 다양하게 이루어지기 때문에 파급력이 큽니다.
        
        1. **Reflected XSS**
            
            스크립트가 포함된 공격성 악성 URL 을 제작하고, 사용자가 해당 URL 을 클릭하였을 때 정보를 얻어내는 공격입니다. URL 이 길면 클라이언트가 의심할 수 있기 때문에, URL 단축을 사용하여 짧은 URL 로 만들어 공격하기도 합니다.
            
            Reflected XSS 는 사용자가 특정 파라미터에 입력한 값을 서버가 응답으로 반사해서 보내줄 때 발생하며, 서버에 악성 스크립트를 저장하지 않기 때문에 서버의 필터링을 피할 수 있습니다. ( = 서버 자체가 오염되지는 않습니다.)
            
            특징
            
            - URL 을 만들고 클릭하여 실행되게 하는 방식으로 **특정인을 대상**으로 공격
            - **URL 파라미터 데이터가 그대로 서버 응답에 삽입**되어 오는 곳에서 발생 (요청과 응답 페이지가 동일하여야 합니다.)
            - 데이터 전달 방식은 **GET 방식**을 사용 (POST 방식은 공격에 활용할 여지 X)
                
                **GET 방식** : 웹에서 데이터를 전송할 때 URL 에 데이터를 붙여서 보내는 방식입니다. 데이터가 URL 에 노출되기 때문에 보안이 취약하고 URL 길이 제한에 의해 많은 양의 데이터를 전송하기에는 적합하지 않습니다.
                
                **POST 방식** : 웹에서 데이터를 서버로 전송할 때 사용되는 방식으로, 데이터를 HTTP 메세지의 본문인 body 에 담아 전송합니다. GET 방식과 달리 URL 에 데이터가 노출되지 않으며 주로 사용자 입력 데이터나 서버 상태 변경과 같은 요청에 사용됩니다.
                
        2. **Stored XSS**
            
            취약한 웹 서버에 악성 스크립트를 심어 놓고, 사용자가 접근할 때 해당 스크립트가 실행되는 공격입니다. 보통 서버에서 필터링을 하기 때문에 공격을 우회하는 것에 어려움이 있지만, 한 번 성공할 시 관리자가 알아차리기 힘들고 광범위한 피해를 입힐 수 있습니다.
            
            특징
            
            - 데이터가 **저장되고 출력**되는 곳에서 발생 (저장 페이지와 출력 페이지가 달라도 상관 X)
            - **접근하는 모든 사람에게 공격이 가능**하기 때문에 광역기 수준의 위험성을 가짐
            
        3. **DOM Based XSS**
            
            Reflected XSS 와 Stored XSS 가 서버의 취약점을 이용하여 악성 스크립트가 포함된 페이지를 전달하는 것이라면,
            
            DOM Based XSS 는 서버와 관련 없이 클라이언트 단에서 파라미터를 처리할 때 발생합니다. 사용자가 공격자가 조작한 URL 을 클릭한 순간 악성 스크립트가 실행되며 사용자 브라우저를 공격합니다.
            
        
        **XSS 의 위험성**
        
        1. 쿠키 정보 및 세션 ID 획득
            
            쿠키는 웹 서버가 브라우저에 보내는 4KB 이하의 작은 텍스트 파일로, 사용자가 웹사이트를 이용하는 동안 사용자 브라우저 파일에 저장하는 파일입니다. 주로 사용자의 상태를 기록하기 위해 쿠키에 로그인 및 버튼 클릭에 대한 정보를 담습니다.
            
            만약 세션 ID 등을 쿠키에 포함하는 경우, XSS 공격을 통해 페이지 사용자의 세션 ID 를 획득하여 공격자가 불법적으로 정상 사용자인 척 가장할 수 있습니다.
            
        2. 시스템 관리자 권한 획득
            
            공격자가 아직 패치되지 않은 취약점에 대해 공격 코드가 실행되도록 하여 사용자의 시스템을 통제할 수 있습니다. 만약 회사와 같은 조직의 개인 PC 가 해킹될 경우 조직 내부로 악성 코드가 이동하여 내부 주요 정보를 탈취할 수 있습니다.
            
        3. 악성코드 다운로드
            
            XSS 공격은 악성 스크립트 자체로 악성 프로그램을 다운할 수는 없습니다. 하지만 사용자가 악성 스크립트가 있는 URL 을 클릭하도록 유도하여 악성 프로그램을 다운 받는 사이트로 리다이렉트 (Redirect) 하거나 트로이 목마 프로그램*을 다운로드 하도록 유도할 수 있습니다.
            
            트로이 목마 프로그램 : 정상 프로그램으로 위장하여 램에 상주하며 시스템 내부 정보를 공격자의 컴퓨터로 빼돌리는 프로그램
            
        4. 거짓 페이지 노출
            
            원래의 페이지에서 사용하지 않던 태그를 사용하여 전혀 관계 없는 페이지를 표시할 수 있습니다. 기타 다른 태그도 사용할 경우 원래 페이지를 일부 변조하여 거짓 페이지를 노출할 수 있어 이를 통한 개인 정보 유출의 위험성이 있습니다.
            
- XSS 방어 전략에 대해 정리해주세요.
    
    **XSS 방지법**
    
    XSS 공격은 IPS, IDS, 방화벽 등으로도 방지할 수 없습니다. 때문에 단순히 문자를 필터링하는 방식으로 방지해야 합니다.
    
    1. **입력 데이터의 이스케이프 (Escape Input Data)**
        
        XSS 공격은 입력 파라미터를 제대로 검증하지 않아 발생하는 취약점입니다.
        
        HTML escaping : 사용자 입력을 HTML 요소에 반영하기 전 특수 문자를 이스케이핑 하여 스크립트 실행을 방지합니다. 입력된 HTML 태그나 스크립트를 그대로 렌더링하는 것을 방지합니다.
        
        ```jsx
        //XSS 에 취약함
        element.innerHTML = userInput;
        
        //XSS 에 안전함
        element.textContent = userInput;
        ```
        
    2. **출력 데이터의 이스케이프 (Escape Output Data)**
        
        똑같이 HTML escaping 방식을 사용하며, 서버에서 클라이언트로 전송되는 데이터를 출력할 때에도 HTML 특수 문자를 이스케이핑 하여 XSS 공격을 방지합니다. 대부분의 웹 프레임 워크에서는 이스케이핑을 자동으로 수행합니다.
        
    
    그밖에도 콘텐츠 보안 정책 (CSP), 입력 데이터의 검증, 세션 쿠키 보호 방식을 통해 XSS 공격을 방지할 수 있습니다.

- 세션 하이재킹은 무엇인가요? 🍠
    
    공격자가 합법적인 사용자의 시스템 접근 권한을 훔치는 것으로, 이미 로그인되어 활성화된 세션을 가로채어 무단으로 접근하는 사이버 공격입니다.
    
    **세션 하이재킹이 발생하는 방식**
    
    1. **사용자 인증 :** 사용자가 웹사이트나 서비스에 로그인하면 시스템은 해당 사용자를 식별하기 위해 고유한 세션 ID 를 발급합니다.
    2. **세션 ID 가로채기 :** 공격자는 다양한 방법을 통해 이 세션 ID를 가로챕니다. 예를 들어, 패킷 스니핑을 통해 네트워크 트래픽을 엿듣거나, 악성코드나 XSS 공격을 통해 쿠키를 훔치는 방식이 있습니다.
    3. **세션 무단 접근 :** 공격자는 가로챈 세션 ID를 사용하여 시스템에 접속하고, 마치 합법적인 사용자처럼 행동하여 시스템의 정보나 서비스에 접근하게 됩니다.
    
    **방어 방법**
    
    - **보안 웹사이트 사용 :** HTTPS 를 사용하는 웹사이트를 이용하여 통신을 암호화하고, 중간에서 데이터를 가로채는 것을 방지합니다.
    - **쿠키 보안 설정 :** 브라우저의 쿠키 설정을 강화하고, 불필요한 쿠키는 삭제합니다.
    - **세션 ID 암호화 :** SSL / TLS ****를 사용하여 세션 ID 를 암호화합니다.
    - **웹 방화벽 사용 :** 세션 하이재킹 공격을 탐지하고 방어하기 위해 웹 방화벽을 도입합니다.
- XSS 공격을 차단하는 방법은 무엇인가요? 🍠
    
    **HttpOnly Cookie** : 세션 쿠키를 HttpOnly 속성으로 설정하여 JavaScript에서 접근할 수 없게 합니다. 이를 통해 XSS 공격이 세션 쿠키를 탈취하는 것을 방지합니다.
    
- 쿠키의 다양한 옵션들에 대해서 정리해주세요. 🍠
    1. 쿠키가 유지되는 기간 (EMA)
    2. 쿠키에 접근할 수 있는 경로와 도메인
    3. 쿠키의 보안 설정을 위한 Secure 및 HttpOnly 속성

- CSRF는 무엇인가요? 🍠
    
    CSRF 란, Cross Site Request Forgery 의 약자로, 사이트 간의 요청 위조를 의미합니다.
    
    웹 보안 취약점의 일종이며, 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위 (데이터 수정, 삭제, 등록 등) 를 특정 웹사이트에 요청하게 하는 공격입니다. 예를 들어, 피해자의 전자 메일 주소를 변경하거나 암호를 변경하거나 자금 이체를 수행하도록 할 수 있습니다.
    
    특성에 따라, 공격자는 사용자의 계정에 대해 완전한 제어권을 얻을 수 있습니다.
    
- CSRF 방어 전략에 대해 정리해주세요. 🍠
    
    CSRF 방지법
    
    - 사용자 입장 : 이상한 URL 을 누르지 않도록 해야 하며, 의심이 되는 메일을 열어보지 않아야 합니다.
    - 웹 개발자 / 운영자 입장 :
        1. Referer Check (리퍼러 체크)
            
            HTTP 요청 헤더 정보에서 Referer 정보를 확인할 수 있습니다. 보통이라면 호스트와 Referer 의 정보값이 일치하므로 둘을 비교합니다. CSRF 공격의 대부분은 리퍼러 검증만으로도 많은 방어를 할 수 있습니다.
            
        2. CAPTCHA 도입
            
            요청 시에 CAPTCHA 를 이용하여, CAPTCHA 인증 코드가 틀리거나 없을 경우 요청을 거부할 수 있습니다.
            
        3. CSRF 토큰 사용
            
            사용자 세션에 임의의 값을 저장하여 모든 요청마다 해당 값을 포함하여 전송하도록 합니다. 서버에 요청 받을 때마다, 세션에 저장된 값과 요청으로 전송된 값이 일치하는지 검증하여 방어하는 방식입니다.
            
- CSRF 토큰의 장점과 단점에 대해 정리해주세요. 🍠
    
    더 강력한 방어를 위한 토큰입니다.
    
    **CSRF 토큰의 장점**
    
    - **모든 브라우저 지원** : 레거시 브라우저에서도 완벽하게 작동
    - **이중 방어 가능** : SameSite 쿠키와 함께 사용하면 더욱 견고한 보안
    - **세밀한 제어** : 특정 액션이나 폼별로 다른 토큰 적용 가능
    - **검증된 방법** : 오랜 기간 사용되어 안정성이 입증
    
    **CSRF 토큰의 단점**
    
    - **구현 복잡도** : 토큰 생성 / 저장 / 검증 로직이 모두 필요
    - **개발 오버헤드** : 모든 폼과 AJAX 요청에 토큰 수동 추가
    - **토큰 관리** : 세션별 토큰 저장 및 만료 처리 필요
    - **완벽하지 않음** : XSS 공격으로 토큰 유출 가능성 O
    
- CAPTCHA는 무엇인가요? 🍠
    
    이 사용자가 사람인지 로봇인지 확인하여 사이트를 보호하는 방식입니다.

- 쿠키 방식으로 인증 정보를 전송할 때 브라우저가 자동으로 쿠키를 포함하는 조건은 무엇인가요? 🍠
    
    서버에서 Set-Cookie 헤더로 쿠키를 설정 시 클라이언트가 같은 도메인으로 요청을 보낼 때 브라우저가 알아서 쿠키를 헤더에 포함시킵니다. 쿠키 설정으로 HttpOnly, Secure, SameSite 속성을 설정하면 됩니다.
    
- 크로스 도메인 환경에서 쿠키를 전송하려면 서버와 클라이언트 측에서 각각 어떤 설정이 필요할까요? 🍠
    
    서버 측 설정
    
    - CORS 설정에서 allowCredentials 를 true 로 설정하여야 합니다.
        
        ⇒ credentials 를 허용할 시 보안상의 이유로 Access-Control-Allow-Origin 에 와일드 카드 (*) 를 사용할 수 없습니다. 
        
        ⇒ 반드시 특정 도메인 명시 필요
        
    
    클라이언트 측 설정
    
    - 크로스 도메인에서는 쿠키가 자동으로 전송되지 않기 때문에 개발자가 쿠키를 포함시켜 달라고 브라우저에게 알려야 합니다.
        
        ⇒  클라이언트에서는 fetch API 를 사용한다면 credentials 의 include 옵션,          axios 사용 시 withCredentials 를 true 로 설정
        
        해당 설정이 없을 시 브라우저는 크로스 도메인 요청에 쿠키를 전송하지 않습니다.
        
- 쿠키 기반 인증에서 CSRF 공격이 발생할 수 있는 원리는 무엇인가요? 🍠
    
    아무런 제약 없이 모든 크로스 도메인 요청에 쿠키가 자동으로 포함된다면, CSRF 공격에 무방비 상태가 됩니다.
    
    예를 들어,
    
    은행 사이트에 로그인한 상태에서 악성 사이트를 방문했다. 만약 브라우저가 크로스 도메인에 자동으로 쿠키를 포함시켰다면 악성 사이트의 JS 코드가 은행 사이트로 송금 요청을 보낼 때 자동으로 인증 쿠키가 포함되어 실제로 송금이 일어납니다
    
- 헤더 방식 인증의 주요 장점(예: CSRF 방어, 선택적 전송, CORS 단순화)을 정리해주세요. 🍠
    
    **장점**
    
    - **CSRF 공격 원천 차단** : 악성 사이트가 요청을 보내도 토큰을 모르기 때문에 인증 불가
    - **선택적 전송** : 인증이 필요 없는 요청에는 토큰을 보내지 않아 네트워크 효율성 향상
    - **CORS 단순화** : credentials 설정이 필요 없어 와일드카드(*) 사용 가능
- 토큰을 클라이언트에 저장할 때 LocalStorage, SessionStorage, 메모리 저장의 장단점을 비교해주세요. 🍠
    
    
    | 구분 | LocalStorage | SessionStorage | 메모리 |
    | --- | --- | --- | --- |
    | 데이터 유지 | 영구적 | 세션 단위 | 휘발성 |
    | 공유 범위 | 도일 출처의 모든 창 | 동일 출처의 모든 창 | 현재 페이지 내 |
    | 장점 | 사용자 편의성, 데이터 영속성 | 로컬 스토리지보다 보안 유리, 탭별로 데이터 격리 | 가장 안전, 빠른 접근 속도 |
    | 단점 | XSS 공격 취약, CSRF 공격 추가 방어 필요 | XSS 공격 취약, 새로고침 시 데이터 유지 | 사용자 경험 저하, 구현 복잡성 (상태 관리 라이브러리) |
    | 활용 | 자동 로그인 정보, 사용자 설정 | 일회성 정보, 입력 폼 데이터 | 가장 이상적 토큰 저장소, 민감한 임시 데이터 |
    | 보안 | 취약 | 취약 | 안전 |
- Single Page Application, Mobile Application, Server Side Rendering Application 에서 여러분들이 생각하는 적합한 인증 전략은 무엇이라고 생각하시나요? 🍠
    1. **SPA** 
        
        서버와 클라이언트가 명확하게 분리되어 있는 구조이므로 각 API 요청이 독립적으로 인증되어야 하는 토큰 기반 방식이 가장 적합합니다.
        
    2. **Mobile Application**
        
        서버와 통신하는 독립적인 클라이언트이므로 똑같이 토큰 기반 방식을 사용하는 것이 표준입니다.
        
    3. **SSR Application**
        
        서버가 페이지 렌더링과 사용자 상태를 모두 관리하는 전통적인 방식이므로, 세션 기반 인증이 가장 간단하고 효과적이며 안전합니다.

- **react-hook-form** 학습 내용 정리
    
    **react-hook-form** 은 폼을 더 쉽고 효율적으로 관리하기 위한 React 라이브러리입니다. 
    
    핵심은 **비제어 컴포넌트(Uncontrolled Components)** 방식으로 동작하여, 사용자가 입력할 때마다 발생하는 불필요한 리렌더링을 최소화해 성능을 최적화하는 데 있습니다.
    
    **핵심 메서드 및 속성**
    
    1. **register** 
        
        입력 필드를 훅에 등록하는 역할을 합니다. register 를 사용하면 해당 필드의 값 / 변경 이벤트 / 유효성 검사 규칙까지 한 번에 관리할 수 있습니다.
        
        - **역할**: 입력 필드를 `react-hook-form` 의 관리하에 둠
        - **사용법**: JSX에서 스프레드 연산자 (`...`) 를 사용해 간단하게 적용
        - **유효성 검사**: `required`, `minLength`, `pattern` 등 다양한 규칙을 두 번째 인자로 전달하여 설정
    2. **handleSubmit**
        
        폼 제출을 처리하는 함수입니다. 이 함수의 가장 큰 특징은 **유효성 검사를 먼저 수행**하고, 모든 필드가 유효할 때만 정의한 콜백 함수를 실행한다는 점입니다.
        
        - **역할**: 폼 제출 및 유효성 검사 트리거
        - **사용법**: `<form>` 태그의 `onSubmit` 이벤트에 연결
    3. **formState**
        
        폼의 현재 상태에 대한 정보를 담고 있는 객체입니다. 이 객체를 통해 폼의 유효성 여부, 에러 메시지, 사용자의 입력 여부 등을 실시간으로 파악할 수 있습니다.
        
        - `errors` : 각 필드의 유효성 검사 실패 시 에러 메시지를 담고 있는 객체
        - `isValid` : 폼 전체의 유효성 여부를 나타내는 boolean 값 (모든 필드가 유효하면 `true`)
        - `isSubmitting` : 폼이 제출 중인지를 나타내는 boolean 값
        - `touchedFields` : 사용자가 한 번이라도 건드린 필드의 목록
    
    **장점**
    
    - **성능** : useState 와 onChange 를 사용하여 각 입력마다 컴포넌트를 리렌더링 하는 대신 ref 를 사용하여 비제어 방식으로 입력값 관리하여 리렌더링을 최소화하고 성능을 최적화함
    - **간결한 코드** : 폼 상태 관리를 위한 `useState`와 이벤트 핸들러를 직접 작성할 필요가 없어 코드량이 줄어들고 가독성이 높아짐
    - **개발자 경험** : `handleSubmit`, `errors` 객체 등 직관적인 API를 제공하여 폼 로직을 쉽고 빠르게 구현
    - **쉬운 유효성 검사** : 내장된 규칙이나 `Zod`, `Yup` 같은 외부 라이브러리와의 연동을 통해 복잡한 유효성 검사도 간편하게 처리
- **Zod** 학습 내용 정리
    
    Zod 는 스키마에서 시작된 라이브러리입니다. 
    
    스키마는 특정 데이터(문자열, 숫자, 객체 등) 가 가져야 할 **모양과 규칙의 집합**입니다. zod 에서는 `z` 객체를 통해 이러한 스키마를 만듭니다.
    
    1. **기본 타입 스키마**
        
        가장 기본적인 데이터 타입을 위한 스키마입니다.
        
        - **`z.string()`** : 문자열
        - **`z.number()`** : 숫자
        - **`z.boolean()`** : 불리언 (`true` / `false`)
        - **`z.date()`** : JavaScript `Date` 객체
        - **`z.enum()`** : 특정 문자열 값들 중 하나만 허용
    2. **유효성 검사 체이닝**
        
        스키마에 메서드를 chain 처럼 연결하여 추가적으로 유효성 검사를 할 수 있습니다.
        
        - **`min()`**, **`max()`** : 최소/최대 길이 또는 크기
        - **`email()`** : 이메일 형식 검사
        - **`url()`** : URL 형식 검사
        - **`optional()`** : 해당 값이 undefined 여도 허용
        - **`default()`** : 값이 없을 경우 기본값 설정
    3. **객체 스키마**
        
        실제 애플리케이션에서는 대부분 객체 형태의 데이터를 다룹니다. `z.object()`를 사용하면 객체의 각 속성에 대한 스키마를 정의할 수 있습니다.
        
    4. **`z.infer`**
        
        **스키마로부터 TypeScript 타입을 자동으로 추론**하는 것입니다. `z.infer<typeofYourSchema>`를 사용하면, Zod 스키마 정의와 실제 데이터 타입 간의 불일치를 원천적으로 방지할 수 있습니다.
        
        - **역할** : Zod 스키마를 기반으로 TypeScript 타입을 생성
        - **장점** : 스키마와 타입을 따로 관리할 필요가 없어 실수가 줄고 유지보수가 쉬워짐
    
    **장점**
    
    - **단일 진실 공급원** : 유효성 검사 규칙만 정의하면 실제 실행 코드의 검증과 TypeScript 의 타입 검사를 모두 해결합니다.
    - **불변성** : Zod 스키마는 불변하기 때문에 예측 가능성이 높습니다
    - **개발자 경험** : 간결하고 직관적인 체이닝 문법과 상세한 에러 메세지 제공