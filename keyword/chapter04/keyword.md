- 세션 방식과 토큰 방식의 가장 큰 차이는 무엇인가요? 🍠
    
    세션과 토큰의 가장 중요한 차이는 사용자의 상태 정보를 어디에 저장하는지 차이이다
    
    - 세션 방식은 실제 사용자 정보를 서버에 저장하고, 클라이언트에는 그 정보를 찾을 수 있는 세션 ID만 전달합니다.
    - 토큰 방식은 사용자 정보를 토큰 자체에 포함시켜, 클라이언트가 직접 보관하고 전송하는 방식입니다.
- 세션을 분산 환경에서 관리할 때 사용할 수 있는 세 가지 전략(Sticky Session, Session Replication, Centralized Session Store)의 특징을 정리해주세요. 🍠
    1. **Sticky Session (세션 고정)**
        - 로드밸런서가 같은 사용자의 요청을 항상 같은 서버로 보내는 방식입니다.
        - 구현이 간단하지만, 서버 장애 시 해당 서버의 모든 세션이 사라지는 단점이 있습니다.
    2. **Session Replication (세션 복제)**
        - 모든 서버가 세션 정보를 공유하는 방식입니다.
        - 서버 간 네트워크 통신이 많아져 성능이 떨어질 수 있습니다.
    3. **Centralized Session Store (중앙 세션 저장소)**
        - Redis 같은 별도 저장소에 모든 세션을 보관하는 방식입니다.
        - 현재 가장 널리 사용되는 방법이며, 분산 환경에서도 안정적으로 세션을 관리할 수 있습니다.
- JWT(Json Web Token)의 장점과 단점을 각각 설명해주세요. 🍠
    
    **장점**
    
    - 확장성이 뛰어남: 서버가 많아도 각 서버가 독립적으로 토큰을 검증할 수 있습니다.
    - MSA 환경에 적합: 각 서비스가 자체적으로 인증을 처리할 수 있습니다.
    
    **단점**
    
    - 한 번 발급된 토큰은 **만료될 때까지 유효**하므로, 사용자를 강제로 로그아웃시키는 등의 보안 이슈가 있을 때 **즉시 처리하기 어렵습니다.**
    - 이를 해결하기 위해 **블랙리스트를 두거나 토큰 만료 시간을 짧게 설정하는 추가적인 처리**가 필요합니다.
- JWT의 즉시 무효화 문제가 생기는 이유와 이를 해결하기 위한 방법은 무엇인가요? 🍠
    
    문제 발생 이유
    
    - 한 번 발급된 토큰은 **만료될 때까지 유효**하기 때문입니다.
    - 서버가 별도의 저장소에 토큰 상태를 관리하지 않기 때문에, **사용자를 즉시 로그아웃시키는 것이 어렵습니다.**
    
    해결 방법
    
    - **블랙리스트를 두고**, 만료 시간을 짧게 설정하는 등의 **추가적인 처리**를 합니다.
- 세션과 토큰을 결합한 하이브리드 방식(JWT + 저장소 메타데이터)의 동작 원리를 간단히 설명해주세요. 🍠
    - JWT를 사용하되, **저장소에 토큰의 메타데이터를 저장**하여 필요 시 해당 토큰을 **무효화할 수 있도록** 합니다.
    - **동작 과정 예시**
        1. JWT의 JTI(JWT ID**)** 클레임을 활용해 각 토큰에 고유 ID를 부여합니다.
        2. **로그아웃 시**, 이 ID를 블랙리스트에 등록합니다.
        3. **요청이 들어오면**, 서버는 토큰을 검증하기 전에 블랙리스트에 포함되어 있는지 확인합니다.
    - 이렇게 하면 JWT의 확장성과 세션의 제어권을 모두 가질 수 있습니다.

    - HTTP는 왜 무상태(Stateless)로 설계되었나요? 🍠
    
    HTTP는 **클라이언트와 서버 간의 통신을 단순하고 확장 가능하게 만들기 위해** 무상태로 설계되었습니다.
    
    1990년대 초 웹이 처음 만들어질 때는 단순히 문서를 주고받는 목적이었기 때문에,
    
    대규모 사용자를 고려하지 않았습니다.
    
    그래서 **확장성과 단순성을 확보하기 위해 무상태성**(Stateless)이 선택되었습니다.
    
- HTTP의 무상태성이 주는 장점과 단점을 각각 정리해주세요. 🍠
    
    장점
    
    - 확장성**:** 서버를 수평 확장하기 쉽습니다. 어떤 서버든 요청을 처리할 수 있으므로 로드밸런싱이 간단합니다.
    - 신뢰성**:** 서버 하나가 죽어도 다른 서버가 즉시 대체 가능합니다. 유지할 상태가 없어 복구가 쉽습니다.
    - 단순성**:** 서버가 클라이언트별 상태를 관리하지 않아도 되므로 구현이 단순합니다.
    
    단점
    
    - 서버가 요청 간의 관계를 알 수 없기 때문에,
        
        로그인 유지, 장바구니, 회원가입 단계 진행 등 “상태 유지”가 필요한 기능을 구현하기 어렵습니다.
        
- 쿠키의 Domain 디렉티브에 대해 정리해주세요. 🍠
    - Domain 디렉티브는 쿠키를 어떤 도메인에 대해 전송할 수 있는지를 결정합니다.
    - 기본적으로 쿠키는 **같은** 도메인으로만 전송됩니다.
    - 하지만 Domain 속성을 설정하면 하위 도메인 간 쿠키 공유가 가능합니다.
    
    ```jsx
    res.setHeader('Set-Cookie', 'sid=1; Domain=yolog.co.kr');
    
    ```
    
    이렇게 설정하면
    
    → `yolog.co.kr` 뿐만 아니라 `login.yolog.co.kr`에서도 같은 쿠키를 전송할 수 있습니다.
    
- 쿠키의 Path 디렉티브에 대해 정리해주세요. 🍠
    - Path 디렉티브는 쿠키가 전송될 URL 경로 범위를 제한합니다.
    - 설정된 경로 이하의 요청에서만 쿠키가 포함됩니다.
    
    ```jsx
    res.setHeader('Set-Cookie', 'sid=1; Path=/private');
    
    ```
    
    - `/private` 요청 시 → 쿠키 전송
    - `/public` 요청 시 → 쿠키 전송되지 않음
- 세션 쿠키와, 영속 쿠키의 차이점을 정리해주세요. 🍠
    - 세션 쿠키 (Session Cookie)
        - 브라우저가 종료되면 삭제됩니다.
        - 기본 쿠키 동작입니다.
    - 영속 쿠키 (Persistent Cookie)
        - 브라우저를 종료해도 지정된 기간 동안 유지됩니다.
        - `Max-Age`나 `Expires` 속성으로 수명을 설정합니다.
    
    ```jsx
    res.setHeader('Set-Cookie', 'sid=1; Max-Age=10');
    
    ```
    
    → 10초 후 쿠키 만료
    
- 쿠키의 보안 속성(HttpOnly, Secure, SameSite)은 각각 어떤 공격을 방어하나요? 🍠
    - HttpOnly:
        - JavaScript에서 `document.cookie`로 쿠키 접근을 막습니다.
        - **XSS(Cross-Site Scripting)** 공격으로부터 보호합니다.
    - Secure**:**
        - HTTPS 연결에서만 쿠키를 전송합니다.
        - *중간자 공격(Man-in-the-Middle)**을 방지합니다.
    - SameSite**:**
        - 크로스 사이트 요청 시 쿠키 전송을 제한합니다.
        - **CSRF(Cross-Site Request Forgery)** 공격을 방어합니다.
        - 옵션
            - `Strict`: 같은 사이트에서만 전송
            - `Lax`: GET 방식의 최상위 이동만 허용
            - `None`: 모든 요청 허용 (단, Secure 필요)
- 쿠키의 한계점(용량, 보안, 네트워크, 도메인 제약)을 정리해주세요. 🍠
    1. 용량 제한
        - 각 쿠키는 약 4KB까지만 저장할 수 있습니다.
        - 브라우저마다 도메인당 쿠키 개수도 제한되어 있습니다.
    2. 보안 취약성
        - 클라이언트에 저장되므로 사용자가 값을 조작할 수 있습니다.
        - 예: `role=user` → `role=admin` 으로 변경 가능
    3. 네트워크 오버헤드
        - 동일 도메인으로 보내는 모든 요청에 쿠키가 자동 포함되어,
            
            이미지나 CSS 요청에도 불필요하게 전송됩니다.
            
    4. 도메인 제약
        - 쿠키는 설정된 도메인에서만 접근 가능하므로,
            
            여러 도메인에 걸친 서비스(MSA, SSO 등)에서는 제약이 생깁니다.
            
- 쿠키만으로 상태 관리를 해결할 수 없는 이유는 무엇인가요? 🍠
    - 쿠키는 단순히 클라이언트에 정보를 저장하고 재전송하는 기능만 제공합니다.
    - 하지만 현대 웹은 로그인 유지, 장바구니, 회원별 상태 관리 등
        
        **서버가 지속적으로 사용자의 상태를 추적해야 하는 기능**이 많습니다.
        
    - 쿠키는 용량·보안·도메인 제한 등의 한계가 있어,
        
        세션이나 토큰 같은 서버-클라이언트 상태 관리 방식이 필요하게 되었습니다.

        - XSS 공격은 무엇인가요?
    
    사용자가 입력한 악성 스크립트가 웹사이트에 저장되거나 반영되어 다른 사용자의 브라우저에서 실행되는 공격이다.
    위험 예: 세션 쿠키 탈취, 피싱 폼 표시, 사용자 대신 악의적 동작 수행, 페이지 변조 등.
    
- XSS 방어 전략에 대해 정리해주세요.
    1. **HTML 정화(sanitization)**
        - 위험한 태그나 속성(`<script>`, `onerror` 등)을 제거.
        - 추천: DOMPurify 같은 검증된 라이브러리 사용.
        - 목적: 입력 내 악성 코드를 아예 삭제해서 실행 불가하게 함.
    2. **HTML 이스케이프(escaping)**
        - 출력 시 `<`, `>`, `&`, `"`, `'` 등을 엔티티로 치환해 브라우저가 HTML/JS로 해석하지 못하게 함.
        - 반드시 `&`를 먼저 치환해야 이중 이스케이프 방지.
        - 예: `<` → `&lt;`, `>` → `&gt;`, `&` → `&amp;`, `"` → `&quot;`, `'` → `&#39;`.
        - 라이브러리 예: lodash의 `_.escape`.
    3. **적용 원칙**
        - 사용자 입력은 신뢰하지 말고 **항상** 처리(정화 또는 이스케이프)해서 출력.
        - 저장형(Stored) XSS는 서버에 그대로 저장되는 경우이므로 입력 정화/이스케이프가 필수.

        - 세션 하이재킹은 무엇인가요? 🍠
    
    세션 하이재킹(Session Hijacking)은 공격자가 **로그인된 사용자의 세션 ID를 탈취해**,
    
    그 사람인 것처럼 행동하는 공격이다.
    
    주로 XSS 같은 취약점을 이용해 사용자의 **세션 쿠키를 훔치는 방식**으로 이루어진다.
    
    세션을 가로채면 로그인 없이도 피해자의 계정에 접근할 수 있다.
    
- XSS 공격을 차단하는 방법은 무엇인가요? 🍠
    1. 입력값 이스케이프 처리
        - `<`, `>`, `&` 같은 특수 문자를 HTML 엔티티로 변환해 브라우저가 코드로 인식하지 않게 한다.
    2. HTML Sanitization 사용
        - DOMPurify 같은 라이브러리로 `<script>` 같은 위험한 태그를 제거한다.
    3. HttpOnly 쿠키 사용
        - JavaScript에서 `document.cookie` 접근을 막아 쿠키 탈취를 원천 차단한다.
- 쿠키의 다양한 옵션들에 대해서 정리해주세요. 🍠
    - HttpOnly**:**
        
        JavaScript 접근 차단 → XSS로 인한 세션 탈취 방지
        
    - Secure:
        
        HTTPS 연결에서만 쿠키 전송 → 중간자 공격 방지
        
    - SameSite:
        
        외부 사이트에서 쿠키 전송 제한 → CSRF 공격 완화
        
        (Strict / Lax / None 설정 가능)
        
    - Path**:**
        
        특정 경로에서만 쿠키가 전송되도록 제한
        
    - Max-Age:
        
        쿠키의 만료 시간 설정 → 일정 시간 후 자동 로그아웃 가능

        - CSRF는 무엇인가요? 🍠
    
    CSRF(Cross-Site Request Forgery)는
    
    **인증된 사용자의 쿠키를 악용해**, 그 사용자가 의도하지 않은 요청을 자동으로 보내게 만드는 공격이다.
    
- CSRF 방어 전략에 대해 정리해주세요. 🍠
    1. SameSite 쿠키 설정
        - 쿠키를 같은 사이트에서만 전송하도록 제한한다.
        - `SameSite=Strict`를 설정하면 다른 도메인(hacker.com 등)에서는 쿠키가 전송되지 않는다.
    2. CSRF 토큰 사용
        - 서버가 HTML 문서나 폼에 **고유한 토큰**을 포함시킨다.
        - 요청 시 이 토큰이 함께 전송되어야 하며, 서버는 토큰이 유효한지 검증한다.
        - 토큰이 없거나 다르면 요청을 거부한다.
    3. CAPTCHA 사용
        - 요청이 자동화된 공격인지, 사람이 직접 한 요청인지를 구분하기 위해 사용한다.
    
    ---
    
- CSRF 토큰의 장점과 단점에 대해 정리해주세요. 🍠
    
    장점
    
    - 모든 브라우저에서 동작 (레거시 환경 포함)
    - SameSite와 함께 사용 시 매우 강력한 방어 가능
    - 폼별로 다른 토큰 적용 가능
    
    단점
    
    - 구현이 복잡하고 개발량이 많다.
    - 모든 요청에 토큰을 넣어야 하므로 관리가 번거롭다.
    - XSS 공격으로 토큰이 유출될 수 있다.
    
    ---
    
    ### 
    
- CAPTCHA는 무엇인가요? 🍠
    
    CAPTCHA는
    
    사람과 컴퓨터(봇)를 구별하기 위한 자동화 테스트이다.
    
    “신호등이 있는 이미지를 선택하세요” 같은 문제를 통해 봇의 자동 요청을 차단한다.
    
    Google reCAPTCHA 같은 서비스를 이용하면 손쉽게 적용할 수 있다.

    - 쿠키 방식으로 인증 정보를 전송할 때 브라우저가 자동으로 쿠키를 포함하는 조건은 무엇인가요? 🍠
    - 같은 도메인(same origin)일 경우: 브라우저가 자동으로 쿠키를 요청에 포함한다.
    - 다른 도메인(cross domain)일 경우: 기본적으로 쿠키를 포함하지 않는다.
        
        → 크로스 도메인 요청에서는 브라우저가 보안상 자동 전송을 차단한다.
        
- 크로스 도메인 환경에서 쿠키를 전송하려면 서버와 클라이언트 측에서 각각 어떤 설정이 필요할까요? 🍠
    - 서버 측:
        - `Access-Control-Allow-Origin`에 특정 도메인을 명시해야 함 ( 사용 불가).
        - `Access-Control-Allow-Credentials: true` 설정 필요.
    - 클라이언트 측:
        - `fetch` → `credentials: 'include'` 옵션 추가.
        - `axios` → `withCredentials: true` 설정.
- 쿠키 기반 인증에서 CSRF 공격이 발생할 수 있는 원리는 무엇인가요? 🍠
    - 브라우저가 쿠키를 자동으로 전송하기 때문.
    - 사용자가 로그인된 상태에서 악성 사이트를 방문하면,
        
        그 사이트의 스크립트가 피해자 쿠키를 포함한 요청을 원래 서버로 보낼 수 있음.
        
    - 서버는 이 요청을 정상적인 사용자 요청으로 인식하여 작업을 수행하게 된다.
- 헤더 방식 인증의 주요 장점(예: CSRF 방어, 선택적 전송, CORS 단순화)을 정리해주세요. 🍠
    1. CSRF 방어:
        - 브라우저가 자동으로 쿠키를 붙이지 않으므로 외부 사이트 요청이 인증되지 않는다.
    2. 선택적 전송:
        - 필요한 요청에만 토큰을 포함시킬 수 있다.
    3. CORS 단순화:
        - `credentials` 설정 없이도 `Access-Control-Allow-Origin: *` 사용 가능.
- 토큰을 클라이언트에 저장할 때 LocalStorage, SessionStorage, 메모리 저장의 장단점을 비교해주세요. 🍠
    
    **LocalStorage**
    
    브라우저를 닫아도 데이터가 유지되어 편리하고 구현이 간단하지만, XSS 공격에 매우 취약하다.
    
    토큰이 영구적으로 남기 때문에 보안 사고 발생 시 피해가 지속될 수 있다.
    
    **SessionStorage**
    
    브라우저 탭을 닫으면 자동으로 삭제되어 LocalStorage보다 상대적으로 안전하다.
    
    하지만 여전히 XSS 공격에는 노출되며, 새 탭을 열면 로그인 정보를 다시 입력해야 하는 불편함이 있다.
    
    **메모리 저장**
    
    가장 안전한 방식으로, 토큰을 자바스크립트 변수나 상태로만 관리하므로 외부 스크립트 접근이 어렵다.
    
    다만 페이지를 새로고침하면 토큰이 사라지기 때문에, 이를 보완하기 위해 보통 Refresh Token을 HttpOnly 쿠키에 따로 저장한다.
    
- Single Page Application, Mobile Application, Server Side Rendering Application 에서 여러분들이 생각하는 적합한 인증 전략은 무엇이라고 생각하시나요? 🍠
    - SPA (Single Page Application)
        - `HttpOnly 쿠키` 기반 인증 → XSS 방어에 강함.
        - 또는 `메모리 + Bearer 헤더` 방식 → 유연하지만 토큰 관리 필요.
        - 새로고침 문제는 Refresh Token을 `HttpOnly 쿠키`로 보관해 해결 가능.
    - Mobile Application
        - 브라우저 쿠키 대신 헤더 방식 사용.
        - iOS Keychain, Android EncryptedSharedPreferences 등 **보안 저장소**에 토큰 보관.
    - SSR (Server-Side Rendering)
        - 쿠키 기반 인증이 자연스럽다.
        - 서버가 쿠키를 읽어 초기 렌더링 시 인증 상태를 유지할 수 있다.
    
    ---