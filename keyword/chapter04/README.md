<h1>chapter4 키워드 정리</h1>

`인증 vs 인가`

- 인증
    - 웹 서비스에 접속하는 사용자가 정말로 자신이 주장하는 사람인지 확인하는 절차.
    - 방법 <br>
        1. 아이디 와 비밀번호 
        2. 소셜 로그인
        3. 2단계 인증 (2FA,MFA)
        4. 생체 인증
    - 인증의 위치
        - REACT와 같은 프론트엔드에서는 로그인 화면을 통해 인증을 시도한다.
        - 사용자가 아이디 / 비밀번호를 입력하면 서버가 확인후 Session or JWT토큰을 발급해준다.
        - 앞으로는 이 발급된 정보가 인증된 사용자라는 증거가 된다.
        <br>
        <br>

- 인가란 ?
    - 인증 다음에 나오는 개념으로 너는 무엇을 할 수 있니? 를 결정하는 과정이다.
    - 인가는 예를들어 너가 표표라는 것을 확인했어 근데 관리자페이지에 접근할 수 있어? 아니면 학생 페이지에서만 접근해야돼? 를 판단하는 과정이다.
    - 방법
        1. 역할기반(RBAC)
            - 사용자를 역할 단위로 구분한다. ex) admin, teacher,student
        2. 속성기반(ABAC)
            - 나이 소소그 결제 상태 등 특정 소속에 따라 권한을 준다.
        3. 정책기반 
            - 시간,장소, 기기 같은 조건을 고려하여 접근을 제어한다.
    - 인가의 위치
        - 라우팅 (페이지 접근제어) 단계에서 나타난다.
        - 예를 들어 로그인은 했지만 admin 권한이 없는 사용자가 관리할 때 사용자가 페이지에 접근하려 하면 403 Forbidden 화면을 보여준다.


`JWT(JSON Web Token) vs Session`

- JWT
    - 사용자가 로그인에 성공하면 서버가 서명된 토큰을 발급한다.
    - 클라이언트는 이후 모든 API 요청에 이 토큰을 HTTP 헤더에 실어 보낸다.
    - 서버는 토큰 안에 들어있는 정보만 확인한다.
    - 장점
        1. 확장성
        2. 서비스 간 공유 용이
        3. 클라이언트 친화적
    - 단점과 주의사항
        1. 토큰 유출 위험 - 토큰이 만료되기 전까지 누구나 사용이 가능.
        2. 즉시 무효화 어려움 - 이미 발급된 토큰은 만료시간 전까지 유효하다.
        3. 보안 설계의 필요성
    - 인증클라이언트 흐름
        1. 로그인 요청
        2. API요청
        3. 토큰 만료 대응
        4. 로그아웃 처리
- Session
    - 사용자가 로그인에 성공하면, 서버가 session ID를 생성하고 session 저장소에 저장한다.
    - 클라이언트는 이 세션 ID가 쿠키로 내려간다.
    - 이후 클라이언트가 API요청을 보낼 때마다 쿠키에 담긴 세션 ID 가 자동으로 전송된다.
    - 서버는 Session ID를 확인하여 이 사용자가 로그인한 사용자다 라고 판단.

    - 장점
        1. 보안 관리가 용이하다. - Session데이터가 서버에 저장됨으로 서버가 마음대로 만료 및 무효화가 가능.
        2. 쿠키 자동 전송 - 같은 도메인 요청에는 자동으로 쿠키를 붙여줌으로, 클라이언트 코드에서 헤더를 직접 조작할 필요가 적다.
        3. 전통적인 방식 - 오래된 웹 프레임워크부터 지금까지 폭넓게 사용됨.
    - 단점 및 주의사항
        1. 서버 확장의 어려움 - 서버에 저장되므로 서버를 늘릴결우 동기화 문제가 발생
        2. 스케일 아웃에 불리하다. - 무상태한 JWT와 다르게 서버 확장성이 떨어진다.
        3. 보안 이슈 - 쿠키의 자동전송으로 인해 다른 사이트에서 의도치 않게 요청을 보내는 CSRF 요청에 취약하다.
    - 관리옵션
        - Httponly - 자바스크립트에서 접근을 불가하게 하여 -> XSS 방어를 강화한다.
        - Secure - HTTPS 에서만 전송되게하여 -> 네트워크 도청을 방지.
        - Samesite - 크로스 사이트 요청에서 쿠키 전송 여부를 제어한다.
            1. Strict: 같은 사이트에서만 전송한다.
            2. Lax : 대부분 안전하다. 기본으로 추천.
            3. None ; Secure 크로스 도메인 환경에서 필요
        - Session 인증 클라이언트 흐름 
            1. 로그인 요청
                - 서버가 사용자 검증 후 Session ID를 생성하여 Sesison 저장소에 저장한다.
                - 세션 ID를 담은 쿠키를 클라이언트에 내려줌.
            2. API 요청  
                - 브라우저가 자동으로 쿠키를 붙여 보낸다.
                - 서버는 세션저장소에서 해당 Session ID를 찾아 인증 확인
            3. 세션 만료/ 로그아웃
                - 서버에서 Session을 삭제하면 사용자는 더이상 인증되지 않는다.
                - 즉시 강제로그아웃이 가능.
            4. REACT에서 주의할 점
                - fetch 나 axios 요청에  `withCredentials:true` 옵션을 주어야 쿠키가 API요청에 포함된다.

`세션방식과 토큰 방식의 차이점은 무엇인가?`

    - 세션방식
        - 세션방식은 실제 사용자 정보를 서버에 저장하고, 그 정보를 찾을 수 있는 세션 ID만 전달하는 방식이다.
    - 토큰방식
        - 사용자 정보를 토큰 자체에 포함시키는 self-contained 방식이다. 토큰 자체에 사용자 ID, 권한, 만료 시간등을 포함하고 서버의 비밀 키로 서명한다.
    
    `세션을 분산 환경에서 관리할 때 사용할 수 있는 세 가지 전략(Sticky Session, Session Replication, Centralized Session Store)의 특징을 정리 `
    
    Sticky Session (세션 고정) : 로드 벨런서가 같은 사용자의 요청을 항상 같은 서버로 보내는 방식이다. 구현이 간단하지만 서버 장애시 해당 서버의 모든 세션이 사라지는 단점이 존재한다.
    
    Session Replication (세션 복제) : 모든 서버가 세션 정보를 공유하는 방식이다. 서버 간 네트워크의 통신이 많아져 성능이 떨어질 수 있다.
    
    Centralized Session Store( 중앙 세션 저장소) : Redis 같은 별도 저장소에 모든 세션을 보관하는 방식. → 가장 많이 사용되는 방식이다.

    ` JWT(Json Web Token)의 장점과 단점을 각각 설명해주세요. `
    
    장점 
    
    - 확장성 : 서버가 100대 1000대든 각 서버는 독립적으로 토큰을 검증할 수 있다. 따라서 MSA에서 각 서비스가 독립적으로 인증을 처리할 수 있다.
    
    단점
    
    - 한번 발급한 토큰은 만료될 때까지 유효하여 , 사용자를 강제로 로그아웃 시키는 등의 보안 유시가 있을 때 이를 즉시 처리하는 것이 어렵다.

    - JWT의 즉시 무효화 문제가 생기는 이유와 이를 해결하기 위한 방법은 무엇인가요? 🍠
    
    서버의 무상태성 떄문에 문제가 생긴다.
    
    JWT는 서버에 상태를 저장하지 않는 토큰이기 때문.
    
    해결방법
    
    | Access+Refresh Token 구조  | Access Token의 시간은 짧게, Refresh Token은 길게 설정 |
    | 블랙리스트 관리 | 로그아웃 시 해당 JWT를 DB/Redis 등에 등록하고 요청마다 토큰이 블랙리스트에 있는지 확인한다. |
- 세션과 토큰을 결합한 하이브리드 방식(JWT + 저장소 메타데이터)의 동작 원리를 간단히 설명해주세요. 

    1. JWT의 JTI클레임을 활용해 각 토큰에 고유 ID를 부여한다.
    2. 로그아웃 시 이 ID를 블랙리스트에 등록한다.
    3. 각 요청이 들어와서 토큰을 검증할 때, 블랙리스트에 들어있는지 확인하고 없는 경우 서명을 검증한다.


`토큰은 무엇인가?`

- Basic Token
    - 아이디 비밀번호 문자열을 Base64로 인코딩하여 Authorization 헤더에 담아 전송.
    - 특징
        - 단순하지만 보안상 위험.

- Bearer Token
    - `Authorization:Bearer<토큰>` 형태로 헤더에 담아 전송
    - 특징
        - 가장 널리 쓰이는 방식
        - Bearer은 이 토큰을 가진 사람은 자격이 있다 라는 의ㅣ미
        - 주로 JWT와 같은 토큰형식이 이 방식으로 전달.

- Access Token vs Refresh Token

1. Access Token
    - 역할 : 요청시 사용자 인증/인가 확인 용도로 사용
    - 수명 : 짧음
    - 저장 위치 : 보통 메모리에 저장

2. Refresh Token
    - 역할 : AccessToken을 발급받기 위해 사용
    - 수명 : 길다 ( 7~30 day), 서버가 바로폐기도 가능
    - 저장위치 : HttpOnly 쿠키에 저장하는 것이 권장

3. AccessToken + RefreshToken 동작흐름
    1. 로그인 -> 서버가 AccessToken + RefreshToken을 발급
    2. API 요청 -> 클라이언트가 AcessToken을 Authorization:Bearer 헤더에 담아 요청
    3. AccessToken 만료 
    4. RefreshToken을 사용하여 새 AccessToken 발급
    5. 재로그인 필요

`클라리언트 저장소 전략`
- 쿠키
    - 특징 
        1. 브라우저가 자동으로 서버에 전송
        2. 만료일 설정 가능
        3. 도메인/경로 제한가능
        4. 보안속성을 제공 
            - `HttpOnly`: JS에서 접근 불가 → XSS 방어
            - `Secure`: HTTPS 환경에서만 전송
            - `SameSite`: 크로스 도메인 요청에서 전송 여부 제어

        5. 장점 
            - 자동전송으로 인한 편리함
            - HttpOnly 옵션으로 자바스크립트 접근을 막을 수 있어 보안성이 높음.
        6. 단점
            - 자동전송이기 떄문에 CSRF 공격위험 존재-> SameSite,CSRF 토큰을 같이 써야 안전.

- HTTP는 왜 무상태(Stateless)로 설계되었나요? 🍠
    
    각 요청과 응답을 독립적인 트랜잭션으로 취급하도록 설계됨.→ 서버가 이전 상태를 기억하지 않아도 되도록 만듬.
    
    → 구조가 단순해지고 동기화 부담이 줄어든다.
    
- HTTP의 무상태성이 주는 장점과 단점을 각각 정리해주세요. 🍠
    
    
    - 장점 
        -  확장성 : 서버들은 서로 상태 공유 필요없이 요청만 처리하면된다. 
        -  단순성 : 서버 코드가 요청 하나하나만 처리함으로 구조가 간단. 
        
        -  클라이언트 상태를 서버에 계속 저장하는 부담이 없음. 
    - 단점
        -  상태유지 불가 : 로그인 상태, 장바구니 같은 사용자 상태를 기본 HTTP만으로는 유지 불가 
        -  상태관리를 직접 구현해야 함으로 복잡도가 증가. 
        - 쿠키 ,세션,토큰 과 같은 경우 추가적인 기술이 필요
- 쿠키의 Domain 디렉티브에 대해 정리해주세요. 🍠
    
    쿠키에 Domain 속성을 지정하면, 해당 도메인 요청에 쿠키가 포함될 수 있다.
    
    반대로 Domain 속성을 지정하지 않으면 기본적으로 쿠키를 발급한 정확한 호스트에서만 전송된다.
    
- 쿠키의 Path 디렉티브에 대해 정리해주세요. 🍠
    
    Path 속성은 쿠키가 어떤 경로 이하의 요청에만 포함될지 지정.
    
- 세션 쿠키와, 영속 쿠키의 차이점을 정리해주세요. 🍠
    
    세션 쿠키 
    
    - 저장 기간 : 브라우저 종료시 삭제.
    - 설정 방법 : Set-Cookie : name=value
    - 사용 예 : 로그인을 유지하지 않는 간단한 인증
    
    영속 쿠키
    
    - 명시된 기간까지 지속간까지 지소
    - Max-Age, Expires 속성 사용
    - “기억하기” , 자동 로그인 같은 기능
- 쿠키의 보안 속성(HttpOnly, Secure, SameSite)은 각각 어떤 공격을 방어하나요? 🍠
    - HttpOnly
        - XSS 공격으로 쿠키 탈취를 방지
    - Secure
        - HTTPS 연결에서만 쿠키가 전송되기 함 → 중간자공격 또는 네트워크 스니핑 방지
    - SameSite
        - 쿠키가 cross-site 요청에서 전송되는 방식을 제어 → CSRF 방어가능성이 증가.
- 쿠키의 한계점(용량, 보안, 네트워크, 도메인 제약)을 정리해주세요. 🍠
    - 용량제한 : 브라우저마다 쿠키 하나당 크기 제한 및 전체 저장 가능한 쿠키 개수도 제한
    - 보안 약점 : 쿠키가 탈취되면 세션 하이재킹이 가능. XSS,CSRF,네트워크 탈취 등
    - 너트워크 오버헤드 : 모든 HTTP 요청마다 쿠키가 헤더에 포함되어 전송 → 데이터낭비 및 속도 저하 가능.
- 쿠키만으로 상태 관리를 해결할 수 없는 이유는 무엇인가요? 🍠
    - HTTP가 본래 무상태 → 상태를 기억하려면 추가 저장소 or 토큰처럼 자체상태 포함 구조가 필요
    - 쿠키는 단순 클라이언트와 서버가 데이터를 교환하는 매개체일뿐 상태로직을 담기엔 한계가 존재.
    - 동적인 상태 변경을 쿠키만으로 일일이 통제하기는 어렵고 복잡.


`로컬 스토리지`
- 특징 
    - 브라우저에 반영구적 저장소
    - 저장용량이 크고 문자열 기반
    - 직접꺼내쓰는 방식 -> 요청 시 자동전송 X
- 장점
    - 사용하기 쉽고 API가 간단
    - 사용자 설정, 토큰 같은 데이터 유지에 유용

- 단점
    - XSS 공격에 취약
    - 수동으로 헤더에 토큰을 넣어야 함.

` XSS 공격은 무엇인가요? `
    
- 웹 애플리케이션의 취약점을 이용하여 공격자가 악의적인 JS코드를 사용자의 브라우저 환경에 삽입하고 실행하게 만드는 공격이다.
    
- XSS 방어 전략에 대해 정리해주세요.
    1. HTML Sanitization(정화)
        - 위험한 HTML 태그와 JS를 제거하는 방법
    2. HTML 이스케이프 처리 
        - HTML 특수 문자를 브라우저가 해석할 수 없는 문자로 변환.
`세션 스토리지`

- 특징 
    - 브라우저 탭 단위 저장소
    - 탭이나 창을 닫으면 자동 삭제
    - API 사용법은 localStorage와 동일.
- 장점 
    - 민감한 데이터를 짧게 유지할 때 좋음
    - 자동삭제
- 단점
    - 탭을 닫으면 데이터가 날라감
    - JS에서 접근가능 -> XSS취약

- 세션 하이재킹은 무엇인가요? 🍠
    - 사용자가 로그인해서 받은 세션토큰을 탈취하거나 예측하여 , 공격자가 그 세션을 가로채 사용자 행세를 하는 공격이다.
    - 방법
        1. 세션 스니핑
        2. XSS
        3. 세션 고정
        4. 브라우저 기반 공격 / 중간자 공격
- XSS 공격을 차단하는 방법은 무엇인가요? 🍠
    1. 입력값 검증 / 필터링
        - 사용자 입력을 서버나 클라이언트 쪽에서 스트립트 태그나 위험한 특수문자 등 포함여부를 검사하거나 제거/ 이스케이프하는 방식
    2. HttpOnly 방식
        - 쿠키에 HttpOnly 속성을 설정하면 JS에서 쿠키를 읽을 수 없음.
    3. HTTPS/Secure 속성 사용
        - 쿠키에 Secure속성을 붙여 HTTPS 환경에서만 전송되게하면 중간에 탈취되는 위험을 줄여준다.

- CSRF란?
    
    Cross-Site-Request Forgery는 인증된 사용자의 쿠키를 악용해, 그 사용자가 의도하지 않은 요청을 자동으로 보내게 만드는 공격
    
- CSRF 방어 전략

    1. SameSite 쿠키 설정
        - 쿠키를 같은 사이트에서만 전송되로록 제한함
        - SameSite=Strict를 설정하면 다른 도메인에서 쿠키가 전송되지 않음.
    2. CSRF 토큰
        - 서버가 HTML 문서나 폼에 고유한 토큰을 포함
        - 요청시 토큰이 함께 전송되게 하며, 서버에서 토큰이 유효한지 검사한다.
        - 토큰이 다르거나 없으면 요청을 거부한다.
    3. CAPTCHA 사용
        - 요청이 로봇처럼 자동화된 공격인지, 사람이 직접한 요청인지 사용한다. ex) 그림 맞추기

- CSRF 토큰의 장점과 단점
    
    장점
    
    - 모든 브라우저에서 동작
    - Samesite와 같이 사용할때 매우 강력하게 방어가 가능
    
    단점
    
    - 모든 요청에 토큰을 넣어야 하므로 관리가번거로움
    - XSS 동작으로 토큰이유출될 수 있음.


- 쿠키 방식으로 인증 정보를 전송할 때 브라우저가 자동으로 쿠키를 포함하는 조건
    
    같은 도메인인 경우 : 브라우저가 자동으로 쿠키를 요청에 포함
    
    다른 도메인의 경우 : 기본적으로 쿠키를 포함하지 않음
    
- 크로스 도메인 환경에서 쿠키를 전송하려면 서버와 클라이언트 측에서 각각 어떤 설정이 필요한가.
    
    서버측
    
    ```Access-Control-Allow-Origin`` 에 특정 도메인을 명시
    
    ```
    Access-Control-Allow-Credentials:true 설정이 필요
    ```
    
    클라이언트 측
    
    ```
    fetch -> credentials :'include'
    axios -> withCredentials:true 
    ```
    
- 쿠키 기반 인증에서 CSRF 공격이 발생할 수 있는 원리
    - 브라우저가 쿠키를 자동으로 전송하기 떄문임
    - 사용자가 로그인된 상태에서 악성 사이트에 방문 → 그 사이트의 스크립트가 피해를 당한 사람의 쿠키를 포함한 요청을 원래 서버로 보낼 수 있음.
    - 이 요청을 정상적인 사용자의 요청으로 인식함
- 헤더 방식 인증의 주요 장점
    1. CSRF 방어
        - 브라우저가 자동으로 쿠키를 보내지 않음으로 외부 사이트 요청이 인증되지 않음
    2. 선택적 전송
        - 필요한 요청에만 토큰을 포함
    3. CORS 단순화
        
        ```jsx
        credentials 설정 없이도 Access-Control-Allow-Origin:* 사용가능
        ```
        
- 토큰을 클라이언트에 저장할 때 LocalStorage, SessionStorage, 메모리 저장의 장단점

    - **LocalStorage**
        - 브라우저를 닫아도 데이터가 유지되어 편리하고 구현이 간단하지만, XSS 공격에 매우 취약하다.
        - 토큰이 영구적으로 남기 때문에 보안 사고 발생 시 피해가 지속될 수 있다.
    - **SessionStorage**
        - 브라우저 탭을 닫으면 자동으로 삭제되어 LocalStorage보다 상대적으로 안전하다.
        - 하지만 여전히 XSS 공격에는 노출되며, 새 탭을 열면 로그인 정보를 다시 입력해야 하는 불편함이 있다.
    - **메모리 저장**
        - 가장 안전한 방식으로, 토큰을 자바스크립트 변수나 상태로만 관리하므로 외부 스크립트 접근이 어렵다.
        - 다만 페이지를 새로고침하면 토큰이 사라지기 때문에, 이를 보완하기 위해 보통 Refresh Token을 HttpOnly 쿠키에 따로 저장한다

`Custom Hook은 왜 사용하는가?`
1. 상태관리 - useState로 값이 바뀌면 화면이 자동으로 리렌더링
2. 부수효과 관리 : useEffect로 언제 API를 호출할지/ 리스너를 붙였다 뗄지 제어
3. 참조유지 : useRef로 리랜더링과 무관한 값을 기억 or DOM을 직접 참조.
4. 전역 데이터 : useContext로 props없이 필요한 곳에서 바로 꺼내쓸 수 있음.

