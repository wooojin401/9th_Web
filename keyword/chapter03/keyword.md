- 전체 리로드 방식과 SPA 라우팅 방식의 가장 큰 차이는 무엇일까? 🍠
    - 전체 리로드 방식 : 페이지 전환마다 전체 초기화
    - SPA 라우팅 방식 : 한 번 로드 후 부분만 교체, 전환이 빠르고 상태 유지가 쉬움
- `preventDefault()`와 `stopPropagation()`의 차이와 역할은 무엇인가? 🍠
    - **`preventDefault()`**: 브라우저의 **기본 동작**을 막음.
        
        예: `<a>` 클릭 시 **전체 리로드**를 막고, 대신 JS로 `pushState()` 후 화면만 교체.
        
    - **`stopPropagation()`**: 이벤트 전파(버블링/캡처링)를 막음. 상위 요소로 이벤트가 전달되지 않게 함.
- 선언적 라우팅(`Route`, `Routes`) 구조가 가지는 장점은 무엇일까? 🍠
    - **구조적**: 경로 ↔ 컴포넌트 매핑을 **JSX로 선언**하니 읽고 유지보수하기 쉬움.
    - **부가기능 내장**: 중첩 라우트, 동적 파라미터, Loader/Action, 에러 경계 등 **복잡한 케이스를 일관된 패턴**으로 처리.
    - **접근성/포커스/스크롤 복원** 같은 **UX 표준 동작**을 라이브러리가 대신 책임.

    - **`fetch`** 정리
    - 브라우저에 **내장된 기본 API** → 따로 설치 필요 없음.
    - 기본 사용법:
        
        ```tsx
        const res = await fetch(url);
        const data = await res.json();
        
        ```
        
        → 응답 객체에서 `.json()`을 한 번 더 호출해야 실제 데이터를 얻음.
        
    - **에러 처리**: 네트워크 에러만 `catch`로 잡힘.
        
        HTTP 상태 코드(404, 500)는 `res.ok`를 직접 확인해야 함:
        
        ```tsx
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        ```
        
- **`axios`** 정리
    - 별도의 설치 필요: `pnpm i axios`
    - 기본 사용법:
        
        ```tsx
        const { data } = await axios.get(url);
        
        ```
        
        → `data`에 바로 JSON이 들어있음.
        
    - **에러 처리**: HTTP 에러(404, 500)도 자동으로 `catch`에 잡힘.
        
        응답 상태 코드와 메시지를 편하게 확인 가능.
        
    - 부가 기능:
        - `baseURL`, `headers` 기본값 설정
        - 요청/응답 인터셉터
        - 요청 취소 등 다양한 편의 기능
- **`fetch`**와 **`axios`**의 차이
    - **설치 여부**
        - Fetch: 브라우저 내장 → 별도 설치 필요 없음
        - Axios: 라이브러리 설치 필요 (`npm`, `pnpm`, `yarn`으로 추가해야 함)
    - **JSON 데이터 처리 방식**
        - Fetch: 응답 후 `res.json()`을 한 번 더 호출해야 실제 데이터 사용 가능
        - Axios: 응답 객체의 `data` 속성에 바로 JSON 데이터가 들어있어 간단하게 사용 가능
    - **에러 처리 방식**
        - Fetch: 네트워크 에러만 `catch`로 잡힘 → 404/500 같은 HTTP 에러는 `res.ok`로 직접 확인해야 함
        - Axios: 네트워크 에러뿐 아니라 HTTP 에러도 자동으로 `catch`로 처리됨 → 에러 핸들링이 편리함