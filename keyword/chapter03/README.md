<h1>3주차 키워드 정리!</h1>

<h2>React Router란?</h2>


- `Routing이란?`
    - 사용자가 웹 브라우저의 주소창에 URL을 입력했을 때,그 URL에 맞는 페이지나 데이터를 찾아 사용자에게 보여주는 과정.

- `Routing의 동작 원리` <br>
    1. 사용자가 특정 URL을 입력하거나, 링크를 클릭하여 새로운 페이지 요청
    2. 요청된 URL에 해당하는 데이터를 서버가 찾아서 연결한다.
    3. 서버는 해당 URL과 매핑된 파일을 클라이언트로 전달
    4. 브라우저는 받은 데이터를 렌더링하여 화면에 페이지 표시
    5. 이 과정에서 전체 페이지가 새로고침되며, 새로운 HTML이 표시된다.

- 한마디로 URL마다 다른 페이지가 로드되는 것!

<h3>CSR(Client-Side Routing)</h3>
- Client-side Rendering, 클라이언트 사우드 라우팅은 SPA 에서 사용되는 방식.

- `동작 방식`<br>
    1. 사용자가 처음 웹사이트에 접속하면, 서버는 index.html과 관련된 JS/CSS만 내려준다.
    2. 이후 사용자가 https://~~ 경로로 이동하면, 서버에 새로운 HTML을 요청하는 것이 아니라, 웹 내부에서 필요한 데이터만 불러와 기존 화면 일부만 업데이트 한다.
    3. Navbar, Sidebar 과 같은 공통 UI는 유지되고, 메인 콘텐츠만 바뀐다.
    - 한마디로! 페이지 전체 새로고침이 일어나지 않는다.
- `특징`
    - 장점
        - 페이지 이동이 빠르고, 앱처럼 부드럽게 동작
        - 서버 요청이 줄어들어 네트워크 비용이 줄어들 수 있음.
        - 공통 UI를 유지하면서 필요한 부분만 바꿀 수 있다.
    - 단점
        - 초기 로딩 속도가 SSR보다 느릴 수 있다.
        - SEO에 불리할 수 있음 (검색 엔진이 JS실행 전에는 내용을 읽지 못한다.)

<h3>SSR(Server-Side Routing)</h3>

 - `동작 방식` <br>
    1. 사용자가 주소창에 https://~~을 입력
    2. 브라우저는 서버에 새로운 페이지를 요청
    3. 서버는 해당 요청에 맞는 HTML,CSS,JS를 찾아서 다시 보내준다.
    4. 브라우저는 받은 파일을 새로 그린다.

- `특징`
    - 장점
        - 초기 로딩 속도가 빠른편이다
        - 검색 엔진에 유리하다.
    - 단점
        - 페이지 이동 시마다 새로고침이 발생해서 UX가 부드럽지 않다.
        - 서버 부하가 커질 수 있다.
    

<h3>React Router란? <h3>

- CSR을 가능하게 해주는 대표적인 라이브러리이다. 페이지 전체를 새로 불러오지 않고 URL 경로에 맞는 컴포넌트만 보여주거나 숨기는 방식

- SPA의 장점을 유지하면서, 마치 여러 페이지가 있는 것처럼 사용할 수 있다.

- `장점!` <br>

    1. URL 경로 활용이 가능하다.
        - 경로가 달라지면 브라우저의 Web History API를 활용할 수 있다.
        - 앞/뒤로 가기 버튼도 자연스럽게 동작한다.
    2. 주소 복사 및 공유 기능
        - 사용자가 특정 페이지에 머무를 때 해당 URL을 복사하여 공유하면 다른 사람도 바로 그 페이지를 볼 수 있다.
        - 그러나! 라우팅 처리를 해야한다. 
    3. 성능 최적화
        - 전체 페이지를 다시 불러오지 않고, 필요한 부분만 업에티르하기 떄문에 불필요한 네트워크 요청을 줄일 수 있다.
        - 사용자 입장에서는 더 빠른 화면 전환 경험이 가능
    4. 부드러운 네비게이션
        - 서버 렌더링 방식처럼 페이지가 깜빡이거나 새로고침되는 현상이 없음.
        - 앱처럼 부드럽게 화면이 바뀌어 UX가 좋아진다. 
    
<h2>pushState, popstate 이벤트, 전체리로드와의 차이</h2>
### 1. pushState()

- 브라우저의 URL을 바꾸지만 , 실제로 서버에 요청하지는 않는다.
- 슥 새로고침(전체 리로드)없이 URL만 바뀐다.
- 첫 번째 인자(state)는 브라우저 히스토리에 저장되는 상태의 객체, 두번쨰는 제목, 3번째는 바꿀 URL로 지정한다.


**' history.pushState({page:1},"","/about"); '**


### 2. popstate이벤트

- 사용자가 뒤로가기/ 앞으로 가기 버튼을 눌렀을 때 실행된다.
- history.back(), history.forward(),history.go()같은 API 호출 시에도 발생한다.
- 이 이벤트 안에서 location.pathname을 확인하여 화면을 갱신하면 된다.

```jsx
window.addEventListener("popstate", (event) => {
  console.log("현재 URL:", location.pathname);
  console.log("저장된 state:", event.state);
});

```

### 차이점은 ??!

- 전체 리로드 `(<a href=’/about”>`
    - 클릭 시 브라우저가 서버에 새 HTML 문서를 요청 → 페이지 전체를 새로 그린다.
    - CSS/JS/이미지 등도 전체 다시 로드
    - 로딩이 걸리거나 무겁게 작동함
- pushState/popstate
    - URL은 바뀌지만 서버 요청은 안간다 → 빠른 전환이 가능
    - 뒤/앞으로 가기 시점에 popstate 이벤트가 발생하여 SPA에서 화면 갱신 트리거역할을 한다.


<h2>전체리로드와 SPA방식의 차이</h2>

### 전체 리로드 방식

```jsx
<a href="/about">
```

- 클릭 시 브라우저가 서버에 새 HTML 문서 요청 → 페이지 전체를 새로 그린다.
- CSS/JS/IMAGE 등도 다시 로드 함
- 전체를 다시 로드함으로 로딩이 오래걸릴 수 있음

### SPA 방식

- 클릭 시 브라우저가 서버에 요청하지 않음.
- 대신 JS가 pushState()로 URL만 바꾼 뒤 , 필요한 부분만 DOM 갱신
- 앱이 끊김없이 전환되는 것 처럼 보인다.

<h2> prevnetDefault()와 stopPropagation()의 차이와 역할 </h2>

### preventDefault()의 역할

- 브라우저의 기본 동작을 막는 역할을 한다.

    - `<a href=”~~”>` 클릭을 해도 링크이동을 막는다.
    - `<form>` 제출 시 페이지 리로드를 막는다.
    - 체크박스 자동 체크 동작을 막는다.
    
    ```jsx
    document.querySelctor("a").addEventListenr("click",(e)=>{
    	e.preventDefault();
    	console.log("클릭 but 이동을 안한다.");
    }
    
    ```
    

### stopPropagation()의 차이와 역할

- 이벤트 버블링 또는 캡쳐링을 막는 역할
- 이벤트가 부모 요소로 전파되는걸 차단하는 역할
- 기본 동작은 그대로 실행되지만 , 상위 요소에 등록된 이벤트 핸들러는 실행되지 않는다.

<h2>선언적 라우팅 구조가 가지는 장점은 무엇일까?? </h2>

- ### 코드 가독성

- 명령형 (if(location.pathname ===…)) 라우팅은 조건문이 늘어나서 복잡해진다.
- 반명 선언적 라우팅은 JSX 안에서 다음과 같은 구조로 표현한다.

    ```jsx
    <Route>
	<Route path="/" element={<Home />} /> 
	<Route path="/about" element={<About />} />
	<Route path="/contact" element={<Contact />} />
</Routes> 
```

- 이를 통해서 경로와 컴포넌트 연결이 한눈에 보이고, 페이지 구조가 시각적으로 드러난다.

<h2>useEffect 기초</h2>

- REACT 컴포넌트는 기본적으로 JSX를 사용해서 UI를 그려주는 역할을 한다. 
- 그러나 단순히 화면만 보여주는 것이 아니라 추가로 실행해야 되는 동작도 필요한 경우가 존재한다.
    - 예를 들어 백엔드 REST API를 호출해서 데이터를 가져오기
    - 데이터 생성, 수정, 삭제 요청 보내기
    - 이벤트 리스너 등록 / 해제하기
    - 타이머 설정하기 
- 이런 것들은 UI를 만드는 것 자체와는 직접적으로 관련은 없지만 컴포넌트가 동작하면서 부수적으로 필요한 작업이다.

- 그래서 이런 걸 부수효과라고 부른다. REACT에서는 이런 Side Effect를 안전하게 다루기 위해 UseEffect 훅을 제공한다.

`실행은 언제 되는가?`
 1. 처음 마운트될 때만 실행 -> API를 딱 한번만 호출하고 싶을때
 2. 특정 값이 변경될 때 실행 -> 예를 들어 searchKeyword 값이 바뀔 때마다 API를 초출
 3. 컴포넌트가 리렌더링 될 때마다 실행 -> 별도의 제약이 없이 실행된다.


